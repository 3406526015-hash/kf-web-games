<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>å½©è‰²ä¸‰ç»´åœ£è¯æ ‘</title>
    <style>
      html, body { height: 100%; margin: 0; overflow: hidden; }
      body { background: radial-gradient(1200px 800px at 50% 0%, #0b1a33 0%, #071226 40%, #050d1c 100%); }
      #info { position: absolute; left: 12px; top: 10px; z-index: 10; color: #cfe8ff; font-family: system-ui, -apple-system, Segoe UI, Roboto, PingFang SC, Noto Sans SC, sans-serif; font-size: 14px; line-height: 1.6; background: rgba(0,0,0,.35); border: 1px solid rgba(255,255,255,.15); padding: 10px 12px; border-radius: 8px; box-shadow: 0 6px 18px rgba(0,0,0,.35); }
      #info b { color: #fff; }
      /* æ˜Ÿå…‰/æµæ˜Ÿé£æ ¼çš„ç¥ç¦æ–‡å­—ä¸ä¸“å±ç•™è¨€ */
      .starry-overlay { position: absolute; inset: 0; pointer-events: none; z-index: 20; }
      .meteor-text { position: absolute; z-index: 3; color: #fff; font-family: "PingFang SC", "Noto Sans SC", system-ui, -apple-system, Segoe UI, sans-serif; font-weight: 500; letter-spacing: 0.5px; text-shadow: 0 0 6px rgba(255,255,255,.9), 0 0 16px rgba(255,255,200,.6), 0 0 28px rgba(120,200,255,.45); opacity: 0.92; animation: twinkle 4.5s ease-in-out infinite; }
      .meteor-text.gradient { background-image: linear-gradient(90deg, #ffb3d1 0%, #ffd86b 35%, #7ad6ff 65%, #ffd86b 100%); background-size: 300% 100%; -webkit-background-clip: text; background-clip: text; color: transparent; text-shadow: none; animation: twinkle 4.5s ease-in-out infinite, gradFlow 8s linear infinite; }
      .meteor-text.small { font-size: 16px; }
      .meteor-text.medium { font-size: 18px; }
      .meteor-text.large { font-size: 20px; }
      @keyframes twinkle {
        0% { filter: blur(0px); opacity: 0.86; }
        50% { filter: blur(0.2px); opacity: 1; text-shadow: 0 0 10px rgba(255,255,255,.95), 0 0 28px rgba(255,255,200,.75), 0 0 42px rgba(120,200,255,.6); }
        100% { filter: blur(0px); opacity: 0.9; }
      }
      /* å³ä¸Šåˆ°å·¦ä¸‹çš„æµæ˜Ÿåˆ’è¿‡ï¼ˆç›´çº¿æ–œåˆ‡ï¼‰ï¼Œå¸¦æ˜äº®æ‹–å°¾ */
      .shooting-star { position: absolute; z-index: 3; width: 180px; height: 2px; background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,1) 55%, rgba(255,220,120,0.0) 100%); box-shadow: 0 0 14px rgba(255,240,180,.85), 0 0 26px rgba(180,220,255,.6); transform-origin: left center; opacity: 1; }
      @keyframes shootDiag {
        0% { transform: translate(0, 0) rotate(var(--diag-angle, -36deg)); opacity: 0.0; }
        10% { opacity: 1; }
        100% { transform: translate(-110vw, 100vh) rotate(var(--diag-angle, -36deg)); opacity: 0.0; }
      }
      /* å½©è‰²æ˜Ÿå…‰ï¼ˆé‡‘/ç²‰/è“ï¼‰å¸¦æ‹–å°¾ä¸é—ªçƒï¼Œæ–¹å‘ç»Ÿä¸€ä¸ºå³ä¸Šåˆ°å·¦ä¸‹ */
      .glow-star { position: absolute; z-index: 3; width: 10px; height: 10px; border-radius: 50%; filter: blur(0.2px); box-shadow: 0 0 10px rgba(255,255,255,.7), 0 0 26px rgba(255,255,200,.45); }
      .glow-star.gold { background: radial-gradient(circle, #fff 0%, #ffd86b 35%, rgba(255,216,107,0.0) 70%); box-shadow: 0 0 14px rgba(255,216,107,.9), 0 0 26px rgba(255,240,180,.6); }
      .glow-star.pink { background: radial-gradient(circle, #fff 0%, #ffb3d1 35%, rgba(255,179,209,0.0) 70%); box-shadow: 0 0 14px rgba(255,179,209,.9), 0 0 26px rgba(255,220,220,.6); }
      .glow-star.blue { background: radial-gradient(circle, #fff 0%, #7ad6ff 35%, rgba(122,214,255,0.0) 70%); box-shadow: 0 0 14px rgba(122,214,255,.9), 0 0 26px rgba(200,240,255,.6); }
      .glow-star::after { content: ""; position: absolute; left: -140px; top: 4px; width: 160px; height: 2px; border-radius: 2px; transform: rotate(var(--diag-angle, -36deg)); filter: blur(0.4px); }
      .glow-star.gold::after { background: linear-gradient(90deg, rgba(255,216,107,.0) 0%, rgba(255,216,107,.9) 50%, rgba(255,216,107,.0) 100%); box-shadow: 0 0 10px rgba(255,216,107,.6); }
      .glow-star.pink::after { background: linear-gradient(90deg, rgba(255,179,209,.0) 0%, rgba(255,179,209,.9) 50%, rgba(255,179,209,.0) 100%); box-shadow: 0 0 10px rgba(255,179,209,.6); }
      .glow-star.blue::after { background: linear-gradient(90deg, rgba(122,214,255,.0) 0%, rgba(122,214,255,.9) 50%, rgba(122,214,255,.0) 100%); box-shadow: 0 0 10px rgba(122,214,255,.6); }
      /* å·¦ä¸Šç•™è¨€ï¼šæ¸å˜æµåŠ¨ï¼ˆç²‰é‡‘-è“é‡‘ï¼‰ï¼Œå­—å·ç•¥å¢ï¼Œä½ç½®ç¨é è¿‘æ ‘ */
      .to-left-msg { position: absolute; z-index: 3; left: 8%; top: 10%; font-family: "LXGW WenKai", "KaiTi", "Noto Serif SC", serif; font-size: 22px; line-height: 1.5; opacity: 0.97; transform: translateY(0px); animation: floatMsg 5.5s ease-in-out infinite, gradFlow 8s linear infinite; white-space: pre-line; background-image: linear-gradient(90deg, #ffb3d1 0%, #ffd86b 35%, #7ad6ff 65%, #ffd86b 100%); background-size: 300% 100%; -webkit-background-clip: text; background-clip: text; color: transparent; text-shadow: none; }
      @keyframes gradFlow { 0% { background-position: 0% 0%; } 100% { background-position: 100% 0%; } }
      @keyframes floatMsg {
        0% { transform: translateY(0px); opacity: 0.92; }
        50% { transform: translateY(-2px); opacity: 1; }
        100% { transform: translateY(0px); opacity: 0.92; }
      }
      /* äº”å½©æå…‰å…‰å¹•ï¼ˆå·¦å³å¯¹ç§°ã€æŸ”å’Œå‘å…‰ï¼›æ›´å°ã€æ›´æµ“ï¼Œç½®äºæœ€åº•å±‚ï¼‰ */
      .aurora-panel { position: absolute; top: 0; bottom: 0; width: 26%; pointer-events: none; z-index: 0; mix-blend-mode: screen; opacity: 0.48; filter: blur(12px) saturate(1.2); }
      .aurora-left { left: 0; }
      .aurora-right { right: 0; }
      .aurora-panel::before { content: ""; position: absolute; inset: 0; background: 
        radial-gradient(80% 60% at 30% 20%, rgba(255,216,107,.45) 0%, rgba(255,216,107,0.0) 60%),
        radial-gradient(70% 60% at 70% 35%, rgba(255,179,209,.40) 0%, rgba(255,179,209,0.0) 55%),
        radial-gradient(90% 70% at 50% 70%, rgba(122,214,255,.40) 0%, rgba(122,214,255,0.0) 65%),
        linear-gradient( -36deg, rgba(255,216,107,.35), rgba(255,179,209,.35), rgba(122,214,255,.35) );
        animation: auroraShift 10s ease-in-out infinite alternate;
      }
      @keyframes auroraShift {
        0% { transform: translateX(0) translateY(0) scale(1.0); filter: hue-rotate(0deg); }
        50% { transform: translateX(2%) translateY(-2%) scale(1.02); filter: hue-rotate(12deg); }
        100% { transform: translateX(-1%) translateY(1%) scale(1.01); filter: hue-rotate(-10deg); }
      }
      /* å•ä¸ªæ–œå‘æå…‰ï¼ˆå³ä¸Šåˆ°å·¦ä¸‹ï¼Œæ‰©å¤§ 3/2 å€ï¼Œç½®äºæœ€åº•å±‚ï¼Œä¸å½±å“æ ‘ä¸åº•ç›˜åŠæ–‡å­—/è´è¶ï¼‰ */
      .aurora-diagonal { position: absolute; inset: -20%; pointer-events: none; z-index: 0; mix-blend-mode: screen; opacity: 0.5; filter: blur(14px) saturate(1.2); transform: rotate(-36deg) scale(1.5); transform-origin: center; }
      .aurora-diagonal::before { content: ""; position: absolute; inset: 0; background:
        radial-gradient(60% 50% at 30% 30%, rgba(255,216,107,.42) 0%, rgba(255,216,107,0.0) 62%),
        radial-gradient(60% 50% at 70% 45%, rgba(255,179,209,.38) 0%, rgba(255,179,209,0.0) 58%),
        radial-gradient(70% 60% at 50% 70%, rgba(122,214,255,.38) 0%, rgba(122,214,255,0.0) 65%),
        linear-gradient(-36deg, rgba(255,216,107,.32), rgba(255,179,209,.32), rgba(122,214,255,.32));
        animation: auroraShift 12s ease-in-out infinite alternate;
      }
      /* è¦†ç›–å±‚è´è¶ï¼ˆå°å°ºå¯¸ã€ä¸‰è‰²ã€é”™è½é£åŠ¨ï¼›ç¿…è†€è½»å¾®æ‰‡åŠ¨ï¼›åœ¨æ–‡å­—ä¹‹ä¸‹ï¼Œæå…‰ä¹‹ä¸Šï¼‰ */
      .overlay-butterfly { position: absolute; z-index: 2; width: 16px; height: 12px; transform-origin: center; opacity: 0.95; will-change: transform, opacity; }
      .overlay-butterfly::before, .overlay-butterfly::after { content: ""; position: absolute; width: 12px; height: 8px; border-radius: 50% 60% 50% 60%; top: 2px; filter: drop-shadow(0 0 6px rgba(255,255,255,.55)); }
      .overlay-butterfly::before { left: -6px; transform-origin: right center; }
      .overlay-butterfly::after { right: -6px; transform-origin: left center; }
      .overlay-butterfly.gold::before, .overlay-butterfly.gold::after { background: radial-gradient(circle, #fff 0%, #ffd86b 40%, rgba(255,216,107,0.0) 70%); box-shadow: 0 0 8px rgba(255,216,107,.8); }
      .overlay-butterfly.pink::before, .overlay-butterfly.pink::after { background: radial-gradient(circle, #fff 0%, #ffb3d1 40%, rgba(255,179,209,0.0) 70%); box-shadow: 0 0 8px rgba(255,179,209,.8); }
      .overlay-butterfly.blue::before, .overlay-butterfly.blue::after { background: radial-gradient(circle, #fff 0%, #7ad6ff 40%, rgba(122,214,255,0.0) 70%); box-shadow: 0 0 8px rgba(122,214,255,.8); }
      .overlay-butterfly.wings { animation: wingFlutter 0.8s ease-in-out infinite; }
      @keyframes wingFlutter {
        0% { transform: rotate(0deg); }
        25% { transform: rotate(8deg); }
        50% { transform: rotate(0deg); }
        75% { transform: rotate(-8deg); }
        100% { transform: rotate(0deg); }
      }
    </style>
  </head>
  <body>
    <!-- æ ¹æ®ç”¨æˆ·è¦æ±‚ï¼Œç§»é™¤å·¦ä¸Šè§’çš„æ–‡å­—è¯´æ˜ï¼ˆ#infoï¼‰ä»¥ä¿æŒç”»é¢çº¯å‡€ -->

    <script type="module">
      // ä½¿ç”¨ esm.sh ä»¥ç¡®ä¿æµè§ˆå™¨å¯ç›´æ¥è§£æä¾èµ–ï¼ˆé¿å… bare specifier å¯¼è‡´çš„ three è§£æé”™è¯¯ï¼‰
      import * as THREE from 'https://esm.sh/three@0.160.0';
      import { OrbitControls } from 'https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls.js';
      import { EffectComposer } from 'https://esm.sh/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js';
      import { RenderPass } from 'https://esm.sh/three@0.160.0/examples/jsm/postprocessing/RenderPass.js';
      import { UnrealBloomPass } from 'https://esm.sh/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js';

const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.35));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.0;
      document.body.appendChild(renderer.domElement);
      // è®©æ¸²æŸ“ç”»å¸ƒä½äºæå…‰ä¹‹ä¸Šï¼ˆé¿å…æå…‰å½±å“æ ‘ä¸åº•ç›˜æ˜¾ç¤ºï¼‰
      renderer.domElement.style.position = 'absolute';
      renderer.domElement.style.zIndex = '1';
      // ç¥ç¦æ–‡å­—ï¼ˆæ¥è¿‘ç¤ºä¾‹å›¾ä¸­çš„æ‰‹å†™æ•ˆæœï¼‰
      const wish = document.createElement('div');
      wish.textContent = 'Merry Christmas';
      wish.style.position = 'absolute';
      wish.style.bottom = '14px';
      wish.style.left = '50%';
      wish.style.transform = 'translateX(-50%)';
      wish.style.color = '#ffffff';
      wish.style.fontFamily = 'Trebuchet MS, system-ui, -apple-system, Segoe UI, PingFang SC, Noto Sans SC, sans-serif';
      wish.style.fontSize = '20px';
      wish.style.textShadow = '0 0 8px rgba(255,255,255,.85), 0 0 16px rgba(255,255,200,.6)';
      wish.style.pointerEvents = 'none';
      document.body.appendChild(wish);
      // èƒŒæ™¯æå…‰ï¼ˆå•ä¸ªæ–œå‘ï¼Œæ”¾åœ¨æœ€åº•å±‚ï¼Œä¸å½±å“æ ‘å’Œåº•ç›˜åŠæ–‡å­—/è´è¶å±•ç¤ºï¼‰
      const bgAurora = document.createElement('div'); bgAurora.className = 'aurora-diagonal'; document.body.appendChild(bgAurora);
      // æ˜Ÿå…‰ç¥ç¦ä¸æµæ˜Ÿï¼ˆè¦†ç›–å±‚ï¼‰
      const overlay = document.createElement('div'); overlay.className = 'starry-overlay'; document.body.appendChild(overlay);
      // ä¸å†ä½¿ç”¨å·¦å³æå…‰ï¼Œæ”¹ä¸ºä»…ä¿ç•™åº•å±‚æ–œå‘å•æå…‰
        // ç¥ç¦è¯­å¥ï¼ˆç»Ÿä¸€åœ¨åœ£è¯æ ‘å³ä¾§ï¼Œä¸”é«˜åº¦ä½äºå·¦ä¸Šè§’ç•™è¨€ï¼‰
        const blessings = [
          { text: 'å¥½è¿è¿è¿', cls: 'large', style: { right: '9%', top: '42%' } },
          { text: 'å¤©å¤©å¼€å¿ƒå“¦', cls: 'medium', style: { right: '7%', top: '50%' } },
          { text: 'è¦å¹¸ç¦ï¼è¦å¿«ä¹å“¦', cls: 'medium', style: { right: '11%', top: '58%' } },
          { text: 'é¡ºé‚å®‰åº·', cls: 'small', style: { right: '8%', top: '66%' } },
          // æŒ‰è¦æ±‚ï¼šå°†â€œä¸€ç›´ä¸€ç›´å¥½å¥½çš„â€å¯¹åº”å¥å­å³ç§»è‡³åŸæ¥è·ç¦»çš„ 2/3ï¼ˆä»¥æœ€åˆ 7% ä¸ºåŸºå‡† â†’ 4.6667%ï¼‰ï¼Œå¹¶åœ¨åç»­å›ºå®šä½ç½®
          { text: 'ä¸€ç›´ä¸€ç›´éƒ½è¦å¥½å¥½çš„å“¦ï¼', cls: 'small', style: { right: '4.6667%', top: '74%' } },
        ];
      const blessingElements = [];
        blessings.forEach((b, i) => {
          const el = document.createElement('div'); el.className = `meteor-text gradient ${b.cls}`; el.textContent = b.text;
          Object.assign(el.style, b.style); el.style.animationDelay = `${i * 0.7}s`; overlay.appendChild(el);
          // è®°å½•åŸå§‹ç™¾åˆ†æ¯”ä½ç½®ï¼Œä¾¿äºåç»­â€œå³ä¸‹è§’æ•´ä½“ä¸‹ç§»åˆ°åŸæ¥ä½ç½®ä½ä¸€åŠâ€åªåº”ç”¨ä¸€æ¬¡
          if (typeof b.style.top === 'string' && b.style.top.endsWith('%')) {
            el.dataset.baseTopPercent = String(parseFloat(b.style.top));
          }
          // ä¸ºç¥ç¦æ–‡æœ¬å¯ç”¨æ‹–æ‹½å¹¶åº”ç”¨å·²ä¿å­˜ä½ç½®
          enableDrag(el);
          applySavedPosition(el);
          // æŒ‡å®šâ€œä¸€ç›´ä¸€ç›´å¥½å¥½çš„â€è¿™å¥å›ºå®šä½ç½®ï¼šä¸å‚ä¸è‡ªåŠ¨æ•´ç†ã€ä¸å…è®¸æ‹–æ‹½
          if (el.textContent && el.textContent.includes('ä¸€ç›´ä¸€ç›´')) {
            el.dataset.userMoved = '1'; // å›ºå®šä½ç½®ï¼Œä¸å†å‚ä¸è‡ªåŠ¨ä¸‹ç§»/é˜²äº¤é”™é‡å®šä½
            el.dataset.shiftApplied = '1';
            el.style.pointerEvents = 'none'; // ç¦æ­¢æ‹–æ‹½
          }
          blessingElements.push(el);
        });
      // å·¦ä¸‹è§’ç¥ç¦ï¼ˆåŒæ ·çš„ç‰¹æ•ˆæ•ˆæœï¼Œä½äºå·¦ä¸‹åŒºåŸŸï¼Œä¸äº¤é”™ä¸é‡å ï¼‰
      const leftBlessings = [
        // å·¦ä¸‹è§’çš„å­—å¾€å·¦è¾¹ç§»åŠ¨åˆ°åŸæ¥ä½ç½®çš„ä¸€åŠè·ç¦»ï¼ˆleft ç™¾åˆ†æ¯”å‡åŠï¼Œå‘å·¦é è¿‘ï¼‰
        { text: 'æŒ£å¤§é’±',   cls: 'medium', style: { left: '10.5%', top: '62%' } },
        { text: 'æš´å¯Œå¯Œ',   cls: 'medium', style: { left: '12%',   top: '70%' } },
        { text: 'ä¸šç»©é•¿è™¹', cls: 'medium', style: { left: '13.5%', top: '78%' } },
        { text: 'æ”¶è·æ»¡æ»¡', cls: 'medium', style: { left: '11.5%', top: '86%' } },
      ];
      const leftBlessingElements = [];
      leftBlessings.forEach((b, i) => {
        const el = document.createElement('div'); el.className = `meteor-text gradient ${b.cls}`; el.textContent = b.text;
        Object.assign(el.style, b.style); el.style.animationDelay = `${i * 0.6}s`; overlay.appendChild(el);
        // è®°å½•åŸå§‹ç™¾åˆ†æ¯”ä½ç½®ï¼Œä¾¿äºåç»­â€œä¸‹ç§»åˆ°åŸæ¥ä½ç½®ä½ä¸€åŠâ€åªåº”ç”¨ä¸€æ¬¡
        if (typeof b.style.top === 'string' && b.style.top.endsWith('%')) {
          el.dataset.baseTopPercent = String(parseFloat(b.style.top));
        }
        // ä¸ºç¥ç¦æ–‡æœ¬å¯ç”¨æ‹–æ‹½å¹¶åº”ç”¨å·²ä¿å­˜ä½ç½®
        enableDrag(el);
        applySavedPosition(el);
        leftBlessingElements.push(el);
      });

      // å…è®¸ç”¨æˆ·æŠŠç¥ç¦æ–‡å­—æ‹–æ‹½åˆ°æŒ‡å®šä½ç½®ï¼Œå¹¶æŒä¹…ä¿å­˜ï¼ˆä¸ä¼šå›åˆ°åŸä½ï¼‰
      function applySavedPosition(el) {
        try {
          const key = `blessingPos:${el.textContent}`;
          const saved = localStorage.getItem(key);
          if (!saved) return;
          const pos = JSON.parse(saved);
          if (typeof pos.left === 'number' && typeof pos.top === 'number') {
            el.style.right = 'auto';
            el.style.left = `${pos.left}px`;
            el.style.top = `${pos.top}px`;
            el.dataset.userMoved = '1';
            el.dataset.shiftApplied = '1'; // é˜²æ­¢åç»­â€œä¸‹ç§»ä¸€åŠâ€å†æ¬¡ä½œç”¨
          }
        } catch {}
      }
      function enableDrag(el) {
        el.style.cursor = 'move';
        let dragging = false; let ox = 0; let oy = 0; let w = 0; let h = 0;
        function onPointerDown(e) {
          dragging = true;
          const rectEl = el.getBoundingClientRect(); const rectOv = overlay.getBoundingClientRect();
          ox = e.clientX - rectEl.left; oy = e.clientY - rectEl.top; w = rectEl.width; h = rectEl.height;
          el.setPointerCapture?.(e.pointerId);
        }
        function onPointerMove(e) {
          if (!dragging) return;
          const rectOv = overlay.getBoundingClientRect();
          let x = e.clientX - rectOv.left - ox;
          let y = e.clientY - rectOv.top - oy;
          // è¾¹ç•Œé˜²æŠ¤ï¼šä¸å‡ºå±å¹•
          x = Math.max(6, Math.min(rectOv.width - w - 6, x));
          y = Math.max(6, Math.min(rectOv.height - h - 6, y));
          el.style.left = `${x}px`;
          el.style.top = `${y}px`;
          el.style.right = 'auto';
          el.dataset.userMoved = '1';
        }
        function onPointerUp(e) {
          if (!dragging) return;
          dragging = false;
          const rectEl = el.getBoundingClientRect(); const rectOv = overlay.getBoundingClientRect();
          const left = rectEl.left - rectOv.left; const top = rectEl.top - rectOv.top;
          try {
            const key = `blessingPos:${el.textContent}`;
            localStorage.setItem(key, JSON.stringify({ left, top }));
          } catch {}
          el.releasePointerCapture?.(e.pointerId);
        }
        el.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerup', onPointerUp);
      }
      // æµæ˜Ÿä¸æ˜Ÿå…‰ç‹¬ç«‹ã€é”™è½çš„ç”Ÿæˆï¼šä»å³ä¸Šåˆ°å·¦ä¸‹ï¼ŒæŒç»­ 0.9-1.8 ç§’ï¼Œé—´éš” 0.5-1.5 ç§’
      function spawnMeteor() {
        const el = document.createElement('div'); el.className = 'shooting-star';
        // èµ·ç‚¹ï¼ˆå³ä¸Šè§’é™„è¿‘ï¼‰çš„éšæœºåç§»ï¼Œå½¢æˆâ€œé”™è½çš„åˆ’è¿‡â€
        el.style.right = `${-2 - Math.random()*6}%`;
        el.style.top = `${-6 + Math.random()*6}%`;
        // è§’åº¦å¾®éšæœºï¼ˆå§‹ç»ˆæœå·¦ä¸‹ï¼‰
        const angle = -36 + (Math.random() - 0.5) * 8; // [-40, -32]deg
        el.style.setProperty('--diag-angle', `${angle}deg`);
        const dur = (Math.random() * 0.9) + 0.9; // 0.9-1.8s
        el.style.animation = `shootDiag ${dur}s linear forwards`;
        overlay.appendChild(el);
        el.addEventListener('animationend', () => el.remove());
      }
      function spawnGlowStar() {
        const colors = ['gold','pink','blue'];
        const color = colors[Math.floor(Math.random()*colors.length)];
        const el = document.createElement('div'); el.className = `glow-star ${color}`;
        el.style.right = `${-2 - Math.random()*5}%`;
        el.style.top = `${-6 + Math.random()*6}%`;
        const angle = -36 + (Math.random() - 0.5) * 8; // [-40, -32]deg
        el.style.setProperty('--diag-angle', `${angle}deg`);
        const dur = (Math.random() * 0.9) + 0.9; // 0.9-1.8s
        el.style.animation = `shootDiag ${dur}s linear forwards, twinkle ${Math.max(1.2, dur)}s ease-in-out infinite`;
        overlay.appendChild(el);
        el.addEventListener('animationend', () => el.remove());
      }
      function scheduleMeteor() {
        const delay = (Math.random() * 1000) + 500; // 0.5-1.5s
        setTimeout(() => { spawnMeteor(); scheduleMeteor(); }, delay);
      }
      function scheduleGlowStar() {
        const delay = (Math.random() * 1000) + 500; // 0.5-1.5s
        setTimeout(() => { spawnGlowStar(); scheduleGlowStar(); }, delay);
      }
      scheduleMeteor();
      scheduleGlowStar();
      // è¦†ç›–å±‚è´è¶ï¼šä¸‰è‰²ï¼ˆé‡‘/ç²‰/è“ï¼‰é”™è½é£åŠ¨ï¼Œéå¸ƒå±å¹•ï¼›ç‹¬ç«‹äºæµæ˜Ÿä¸æ˜Ÿå…‰
      const overlayButterflies = new Set();
      function spawnOverlayButterfly() {
        if (overlayButterflies.size > 56) return; // æ‰©å……æ•°é‡ä¸Šé™åˆ°åŸæ¥çš„ä¸¤å€
        const colors = ['gold','pink','blue'];
        const color = colors[Math.floor(Math.random()*colors.length)];
        const el = document.createElement('div'); el.className = `overlay-butterfly wings ${color}`;

        // ä»…åœ¨â€œæ ‘çš„å±å¹•èŒƒå›´ä¹‹å¤–â€ç”Ÿæˆï¼Œå‘å¤–æ‰©å……åŒºåŸŸï¼ˆä¸åœ¨åŸæœ¬åŒºåŸŸå†…å¢åŠ è´è¶ï¼‰
        const overlayRect = overlay.getBoundingClientRect();
        const treeRect = getTreeScreenRect();
        const margin = 60; // å¤–æ‰©å®‰å…¨è·ç¦»ï¼ˆpxï¼‰ï¼Œé¿å…ç”Ÿæˆåœ¨æ ‘çŸ©å½¢è¾¹ç¼˜
        let leftPx = 0, topPx = 0;
        // ä¼˜å…ˆåœ¨å·¦ä¸Šè§’ä¸å³ä¸Šè§’ç”Ÿæˆï¼šæé«˜ä¸Šæ–¹åŒºåŸŸçš„æ¦‚ç‡ï¼Œå¹¶åå‘å·¦å³ä¸¤ä¾§
        const rand = Math.random();
        let region = 2; // é»˜è®¤ä¸Šæ–¹
        if (rand < 0.2) region = 0; // å³ä¾§ï¼ˆ20%ï¼‰
        else if (rand < 0.4) region = 1; // å·¦ä¾§ï¼ˆ20%ï¼‰
        else if (rand < 0.85) region = 2; // ä¸Šæ–¹ï¼ˆ45%ï¼‰
        else region = 3; // ä¸‹æ–¹ï¼ˆ15%ï¼‰
        if (region === 0) { // å³ä¾§
          const minL = Math.min(overlayRect.width - 10, treeRect.maxX + margin);
          leftPx = minL + Math.random() * Math.max(10, overlayRect.width - minL - 10);
          topPx = Math.random() * (overlayRect.height - 10);
        } else if (region === 1) { // å·¦ä¾§
          const maxL = Math.max(10, treeRect.minX - margin);
          leftPx = Math.random() * (maxL - 10);
          topPx = Math.random() * (overlayRect.height - 10);
        } else if (region === 2) { // ä¸Šæ–¹ï¼šå†ç»†åˆ†ä¸ºå·¦ä¸Š/å³ä¸Šä¸¤ä¸ªæ‰‡åŒºï¼Œå¢åŠ ä¸‰è‰²è´è¶åˆ°è¿™ä¸¤ä¸ªåŒºåŸŸ
          const maxT = Math.max(10, treeRect.minY - margin);
          topPx = Math.random() * (maxT - 10);
          const leftOrRight = Math.random() < 0.5 ? 'left' : 'right';
          if (leftOrRight === 'left') {
            // å·¦ä¸Šï¼šå±å¹•å·¦åŠéƒ¨åˆ†
            leftPx = Math.random() * ((overlayRect.width * 0.44) - 10);
          } else {
            // å³ä¸Šï¼šå±å¹•å³åŠéƒ¨åˆ†
            const minL = overlayRect.width * 0.56;
            leftPx = minL + Math.random() * Math.max(10, overlayRect.width - minL - 10);
          }
        } else { // ä¸‹æ–¹
          const minT = Math.min(overlayRect.height - 10, treeRect.maxY + margin);
          topPx = minT + Math.random() * Math.max(10, overlayRect.height - minT - 10);
          leftPx = Math.random() * (overlayRect.width - 10);
        }
        // åŒé‡ä¿éšœï¼šå¦‚æœä»åœ¨æ ‘çŸ©å½¢å†…ï¼Œåˆ™æ¨åˆ°å³ä¸Šå¤–ä¾§
        if (leftPx >= treeRect.minX && leftPx <= treeRect.maxX && topPx >= treeRect.minY && topPx <= treeRect.maxY) {
          leftPx = Math.min(overlayRect.width - 10, treeRect.maxX + margin + Math.random()*120);
          topPx = Math.max(10, treeRect.minY - margin - Math.random()*120);
        }

        el.style.left = `${leftPx}px`;
        el.style.top = `${topPx}px`;

        const angle = -36 + (Math.random() - 0.5) * 10; // [-41, -31]deg
        el.style.setProperty('--diag-angle', `${angle}deg`);
        const dur = (Math.random() * 2.6) + 2.6; // 2.6-5.2s
        el.style.animation = `shootDiag ${dur}s linear forwards, wingFlutter ${0.7 + Math.random()*0.4}s ease-in-out infinite`;
        overlay.appendChild(el);
        overlayButterflies.add(el);
        el.addEventListener('animationend', () => { overlayButterflies.delete(el); el.remove(); });
      }
      function scheduleButterfly() {
        const delay = (Math.random() * 600) + 300; // 0.3-0.9s
        setTimeout(() => { spawnOverlayButterfly(); scheduleButterfly(); }, delay);
      }
      scheduleButterfly();
      // å·¦ä¸Šè§’æ—è¾¹ä¸€ç‚¹çš„ä¸“å±ç•™è¨€
      const toMsg = document.createElement('div'); toMsg.className = 'to-left-msg';
      toMsg.textContent = 'TOï¼šæ•°å®¶å°ä¼™ä¼´\nå¹³å®‰å–œä¹ï¼Œå²å²æ— å¿§'; overlay.appendChild(toMsg);

      // å·¦ä¸Šè§’â€œç³–æœæŒ‰é’®â€ï¼šæ§åˆ¶åœ£è¯æ ‘çš„æ—‹è½¬/åœæ­¢
      const candyBtn = document.createElement('button');
      candyBtn.textContent = 'ğŸ¬';
      candyBtn.title = 'åˆ‡æ¢åœ£è¯æ ‘æ—‹è½¬/åœæ­¢';
      candyBtn.style.position = 'absolute';
      candyBtn.style.top = '8px';
      candyBtn.style.left = '8px';
      candyBtn.style.zIndex = '12';
      candyBtn.style.width = '36px';
      candyBtn.style.height = '36px';
      candyBtn.style.borderRadius = '50%';
      candyBtn.style.border = 'none';
      candyBtn.style.cursor = 'pointer';
      candyBtn.style.fontSize = '20px';
      candyBtn.style.lineHeight = '36px';
      candyBtn.style.background = 'radial-gradient(circle at 30% 30%, #ff89b4, #ff6fa0 60%, #ffb1c9)';
      candyBtn.style.boxShadow = '0 2px 8px rgba(255, 120, 170, 0.45), inset 0 0 6px rgba(255,255,255,0.6)';
      candyBtn.style.color = '#fff';
      overlay.appendChild(candyBtn);
      function updateCandyVisual() {
        if (autorotate) {
          candyBtn.style.filter = 'drop-shadow(0 0 6px rgba(255,150,190,0.6))';
          candyBtn.style.opacity = '1.0';
        } else {
          candyBtn.style.filter = 'grayscale(0.2)';
          candyBtn.style.opacity = '0.85';
        }
      }
      candyBtn.addEventListener('click', () => {
        autorotate = !autorotate;
        if (autorotate) { rotationBase = treeGroup.rotation.y; rotationStartTime = clock.getElapsedTime(); }
        updateCandyVisual();
      });

      const scene = new THREE.Scene();
      // å…¨å±€ç¼©æ”¾å‚æ•°ï¼šæ ‘ä½“ 1.5 å€
      const TREE_SCALE = 1.5;
      scene.fog = new THREE.FogExp2(0x0b1730, 0.035);

      const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(10, 9, 14);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.06;
      controls.maxPolarAngle = Math.PI * 0.95;
      controls.minDistance = 8;
      controls.maxDistance = 30;

      scene.add(new THREE.HemisphereLight(0x86c5ff, 0x21406b, 0.65));
      const sun = new THREE.DirectionalLight(0xffffff, 1.0);
      sun.position.set(10, 20, 10);
      sun.castShadow = true;
      // å°å¹…é™ä½é˜´å½±è´´å›¾å°ºå¯¸ä»¥æå‡æ€§èƒ½
      sun.shadow.mapSize.set(768, 768);
      scene.add(sun);

    const groundGeo = new THREE.CircleGeometry(22.5, 64); // åº•ç›˜åœ¨å½“å‰åŸºç¡€ä¸Šå†å¢å¤§ä¸º 5/4 å€ï¼ˆ18 -> 22.5ï¼‰
      const groundMat = new THREE.MeshPhysicalMaterial({ color: 0xe8f5ff, roughness: 0.9, transmission: 0.0, reflectivity: 0.2 });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      const treeGroup = new THREE.Group();

      const trunkGeo = new THREE.CylinderGeometry(0.6, 0.8, 3.2, 16);
      const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5a3e2b, roughness: 0.9 });
      const trunk = new THREE.Mesh(trunkGeo, trunkMat);
      trunk.position.y = 1.6;
      trunk.castShadow = true;
      trunk.receiveShadow = true;
      treeGroup.add(trunk);

      const foliageMaterial = new THREE.MeshPhysicalMaterial({ color: 0x2fa84e, roughness: 0.65, metalness: 0.1 });
      const layers = 5;
      const baseRadius = 5.0;
      const baseHeight = 3.0;
      let currentY = trunk.position.y + 1.2;
      const foliageCones = [];
      for (let i = 0; i < layers; i++) {
        const r = baseRadius * (1.0 - i / (layers + 0.5)) * 0.75;
        const h = baseHeight * (1.0 - i / (layers + 0.7)) * 0.9;
        const coneGeo = new THREE.ConeGeometry(r, h, 32, 8);
        const cone = new THREE.Mesh(coneGeo, foliageMaterial.clone());
        cone.position.y = currentY + h / 2;
        cone.castShadow = true;
        cone.receiveShadow = true;
        cone.rotation.y = Math.random() * Math.PI * 2;
        treeGroup.add(cone);
        foliageCones.push({ mesh: cone, radius: r, height: h });
        currentY += h * 0.78;
      }

      function createStarShape(R = 1.2, r = 0.55, points = 5) {
        const shape = new THREE.Shape();
        const step = Math.PI * 2 / (points * 2);
        let angle = -Math.PI / 2;
        for (let i = 0; i < points * 2; i++) {
          const rad = (i % 2 === 0) ? R : r;
          const x = Math.cos(angle) * rad;
          const y = Math.sin(angle) * rad;
          if (i === 0) shape.moveTo(x, y); else shape.lineTo(x, y);
          angle += step;
        }
        shape.closePath();
        return shape;
      }
      const starShape = createStarShape(1.2, 0.55, 5);
      const starExtrude = new THREE.ExtrudeGeometry(starShape, { depth: 0.5, bevelEnabled: true, bevelSegments: 2, bevelThickness: 0.12, bevelSize: 0.12 });
      const starMat = new THREE.MeshPhysicalMaterial({ color: 0xffd34f, emissive: 0xffc233, emissiveIntensity: 1.4, roughness: 0.35, metalness: 0.4 });
      const star = new THREE.Mesh(starExtrude, starMat);
      const topY = currentY + 0.6;
      star.position.set(0, topY, 0);
      star.rotation.y = Math.random() * Math.PI * 2;
      star.castShadow = true;
      treeGroup.add(star);

      // æ˜Ÿæ˜Ÿé‡‘è‰²â€œäº®æ™¶æ™¶â€æ•ˆæœï¼šæ·»åŠ é‡‘è‰²å…‰æ™•ä¸å°é—ªå…‰ç²’å­
      function makeHaloTexture(color = '#ffd34f') {
        const c = document.createElement('canvas');
        c.width = c.height = 128;
        const ctx = c.getContext('2d');
        const g = ctx.createRadialGradient(64, 64, 10, 64, 64, 64);
        // é™ä½ä¸­å¿ƒäº®åº¦ä¸å¤–åœˆå¼ºåº¦ï¼Œä½¿æ˜Ÿå½¢è¾¹ç¼˜æ›´æ¸…æ™°
        g.addColorStop(0.0, 'rgba(255, 220, 100, 0.65)');
        g.addColorStop(0.5, 'rgba(255, 220, 100, 0.25)');
        g.addColorStop(1.0, 'rgba(255, 220, 100, 0.0)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(64, 64, 64, 0, Math.PI * 2);
        ctx.fill();
        const tex = new THREE.CanvasTexture(c);
        tex.colorSpace = THREE.SRGBColorSpace;
        return tex;
      }
      const haloMat = new THREE.SpriteMaterial({ map: makeHaloTexture(), color: 0xffffff, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending });
      const starHalo = new THREE.Sprite(haloMat);
      // ç¼©å°å…‰æ™•ï¼Œé¿å…é®æŒ¡è¾¹ç¼˜è½®å»“
      starHalo.scale.set(2.2, 2.2, 1);
      starHalo.position.copy(star.position).add(new THREE.Vector3(0, 0.1, 0));
      scene.add(starHalo);

      const sparkleGroup = new THREE.Group();
      scene.add(sparkleGroup);
      const sparkleTexCanvas = (() => {
        const c = document.createElement('canvas');
        c.width = c.height = 64;
        const ctx = c.getContext('2d');
        ctx.clearRect(0,0,64,64);
        ctx.translate(32,32);
        ctx.fillStyle = 'rgba(255,255,255,0.95)';
        for (let i=0;i<4;i++) {
          ctx.rotate(Math.PI/2);
          ctx.beginPath();
          ctx.ellipse(16,0,10,2.2,0,0,Math.PI*2);
          ctx.fill();
        }
        const tex = new THREE.CanvasTexture(c);
        tex.colorSpace = THREE.SRGBColorSpace;
        return tex;
      })();
      const sparkleMat = new THREE.SpriteMaterial({ map: sparkleTexCanvas, color: 0xfff3a0, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending });
      const sparkles = [];
      for (let i = 0; i < 24; i++) {
        const s = new THREE.Sprite(sparkleMat.clone());
        const radius = 0.7 + Math.random() * 1.1;
        const angle = Math.random() * Math.PI * 2;
        const speed = (Math.random() * 0.6 + 0.3) * (Math.random() < 0.5 ? 1 : -1);
        const phase = Math.random() * Math.PI * 2;
        s.scale.setScalar(0.35 + Math.random() * 0.35);
        s.position.set(
          star.position.x + Math.cos(angle) * radius,
          star.position.y + (Math.random() - 0.5) * 0.4,
          star.position.z + Math.sin(angle) * radius
        );
        sparkleGroup.add(s);
        sparkles.push({ sprite: s, angle, radius, speed, phase });
      }

      // èˆå°èƒŒæ™¯â€œäº”è‰²æµæ˜Ÿâ€ä»é¡¶ç«¯æ»‘è½
      function makeMeteorTexture() {
        const c = document.createElement('canvas'); c.width = 128; c.height = 32; const ctx = c.getContext('2d');
        const g = ctx.createLinearGradient(0,16,128,16);
        g.addColorStop(0.0,'rgba(255,255,255,0.0)');
        g.addColorStop(0.2,'rgba(255,255,255,0.6)');
        g.addColorStop(0.7,'rgba(255,255,255,0.95)');
        g.addColorStop(1.0,'rgba(255,255,255,0.0)');
        ctx.fillStyle = g; ctx.fillRect(0,0,128,32);
        const tex = new THREE.CanvasTexture(c); tex.colorSpace = THREE.SRGBColorSpace; return tex;
      }
      const meteorTex = makeMeteorTexture();
      const meteorColors = [0xff5a5a, 0x5ac8ff, 0x5aff94, 0xffd34f, 0xb388ff]; // äº”è‰²
      const meteorGroup = new THREE.Group(); meteorGroup.position.z = -18; meteorGroup.renderOrder = 0;
      scene.add(meteorGroup);
      const meteors = [];
      const meteorCount = 32;
      for (let i=0;i<meteorCount;i++) {
        const col = new THREE.Color(meteorColors[i % meteorColors.length]);
        const mat = new THREE.SpriteMaterial({ map: meteorTex, color: col, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending, opacity: 0.9 });
        const spr = new THREE.Sprite(mat);
        const length = 2.6 + Math.random()*1.8; spr.scale.set(length, 0.5, 1);
        spr.position.set((Math.random()-0.5)*26, topY + 2 + Math.random()*2, -18);
        spr.rotation.z = -Math.PI/12 + (Math.random()-0.5)*0.12; // å¾®å€¾æ–œ
        meteorGroup.add(spr);
        const vy = 0.9 + Math.random()*1.4; const vx = -0.15 + (Math.random()-0.5)*0.12; const phase = Math.random()*Math.PI*2;
        meteors.push({ sprite: spr, vx, vy, phase });
      }

      const bulbColors = [0xff3b3b, 0x3b9cff, 0xffa600, 0x9b59ff, 0x3cff8f];
      const bulbs = [];
      // åº•å±‚è¾¹ç¼˜æ‚¬æŒ‚æŒ‚ä»¶ï¼ˆé“ƒé“›ã€è´è¶ç»“ï¼‰åˆ—è¡¨ï¼Œç”¨äºåŠ¨ç”»æ›´æ–°
      const bottomHangings = [];
      // é¢œè‰²æ··åˆå·¥å…·ï¼šå°† hexA ä¸ hexB æŒ‰æ¯”ä¾‹ t çº¿æ€§æ··åˆï¼Œè¿”å›æ··åˆåçš„åå…­è¿›åˆ¶é¢œè‰²
      function mixHexColor(hexA, hexB, t) {
        const rA = (hexA >> 16) & 255, gA = (hexA >> 8) & 255, bA = hexA & 255;
        const rB = (hexB >> 16) & 255, gB = (hexB >> 8) & 255, bB = hexB & 255;
        const r = Math.round(rA * (1 - t) + rB * t);
        const g = Math.round(gA * (1 - t) + gB * t);
        const b = Math.round(bA * (1 - t) + bB * t);
        return (r << 16) | (g << 8) | b;
      }

      // åœ¨æ‚¬æŒ‚æŒ‚ç‚¹é™„è¿‘ä¸å¯¹åº”æ ‘å±‚å¢åŠ äº®äº®çš„è£…é¥°ï¼ˆå°å½©ç¯/å°ç¤¼ç‰©/å°èŠ±èŠ±ï¼‰
      function addAccentItemsNearAnchor(anchorPos, baseColor) {
        if (!anchorPos) return;
        const accentGroup = new THREE.Group();
        // ç•¥å¾®å‘ä¸Šã€å¹¶åœ¨å‘¨å›´å¾®å°æ•£å¼€
        accentGroup.position.copy(anchorPos).add(new THREE.Vector3((Math.random()-0.5)*0.08, 0.09 + Math.random()*0.06, (Math.random()-0.5)*0.08));

        const pastel = mixHexColor(baseColor, 0xffffff, 0.6);
        const bright = mixHexColor(baseColor, 0xffffff, 0.75);

        function makeFairyLight() {
          const geo = new THREE.SphereGeometry(0.028, 12, 8);
          const mat = new THREE.MeshStandardMaterial({ color: bright, emissive: bright, emissiveIntensity: 0.85, metalness: 0.15, roughness: 0.35 });
          const bulb = new THREE.Mesh(geo, mat);
          bulb.position.set((Math.random()-0.5)*0.09, (Math.random())*0.04, (Math.random()-0.5)*0.09);
          accentGroup.add(bulb);
          // å°å…‰æ™•
          const haloCol = mixHexColor(baseColor, 0xffffff, 0.82);
          const halo = new THREE.Sprite(new THREE.SpriteMaterial({ map: makeHaloTexture('#ffffff'), color: haloCol, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending }));
          halo.scale.setScalar(0.22 + Math.random()*0.12);
          halo.position.copy(bulb.position).add(new THREE.Vector3(0, 0.01, 0));
          accentGroup.add(halo);
        }

        function makeMiniGift() {
          const geo = new THREE.BoxGeometry(0.06, 0.06, 0.06);
          const giftCol = mixHexColor(baseColor, 0xffffff, 0.4 + Math.random()*0.2);
          const mat = new THREE.MeshStandardMaterial({ color: giftCol, emissive: mixHexColor(giftCol, 0xffffff, 0.35), emissiveIntensity: 0.42, metalness: 0.25, roughness: 0.45 });
          const box = new THREE.Mesh(geo, mat);
          box.position.set((Math.random()-0.5)*0.09, (Math.random())*0.05, (Math.random()-0.5)*0.09);
          accentGroup.add(box);
          // ç®€æ˜“ä¸å¸¦ï¼ˆä¸¤æ¡ç»†æ¡ï¼‰
          const ribbonMat = new THREE.MeshStandardMaterial({ color: mixHexColor(giftCol, 0xffffff, 0.2), emissive: mixHexColor(giftCol, 0xffffff, 0.45), emissiveIntensity: 0.4, metalness: 0.3, roughness: 0.4 });
          const r1 = new THREE.Mesh(new THREE.BoxGeometry(0.062, 0.008, 0.008), ribbonMat);
          const r2 = new THREE.Mesh(new THREE.BoxGeometry(0.008, 0.062, 0.008), ribbonMat);
          r1.position.copy(box.position);
          r2.position.copy(box.position);
          accentGroup.add(r1, r2);
        }

        function makeLittleFlower() {
          const flower = new THREE.Group();
          const petalCol = pastel;
          const petalMat = new THREE.MeshStandardMaterial({ color: petalCol, emissive: mixHexColor(petalCol, 0xffffff, 0.5), emissiveIntensity: 0.5, roughness: 0.4, metalness: 0.2 });
          const petalGeo = new THREE.SphereGeometry(0.02, 10, 8);
          const r = 0.032;
          for (let k = 0; k < 5; k++) {
            const p = new THREE.Mesh(petalGeo, petalMat);
            const ang = (Math.PI*2) * (k/5);
            p.position.set(Math.cos(ang)*r, 0, Math.sin(ang)*r);
            flower.add(p);
          }
          const core = new THREE.Mesh(new THREE.SphereGeometry(0.015, 10, 8), new THREE.MeshStandardMaterial({ color: mixHexColor(baseColor, 0xffe59e, 0.5), emissive: 0xffe59e, emissiveIntensity: 0.6 }));
          flower.add(core);
          flower.position.set((Math.random()-0.5)*0.08, 0.02 + Math.random()*0.04, (Math.random()-0.5)*0.08);
          accentGroup.add(flower);
        }

        const count = 2 + Math.floor(Math.random()*2); // 2~3 ä¸ª
        for (let i = 0; i < count; i++) {
          const t = Math.random();
          if (t < 0.33) makeFairyLight();
          else if (t < 0.66) makeMiniGift();
          else makeLittleFlower();
        }
        treeGroup.add(accentGroup);
      }
      // é”™è½æœ‰è‡´çš„åˆ†å¸ƒï¼šéšæœºç¯æ•°ä¸æ¯ç¯æ•°é‡ï¼Œå¸¦å±€éƒ¨â€œç°‡çŠ¶â€åˆ†å¸ƒ
      foliageCones.forEach(({ mesh, radius, height }, idx) => {
        const ringCount = 6 + Math.floor(Math.random() * 6);      // 6-11 ç¯
        const clusterCenters = Array.from({ length: 3 }, () => Math.random() * Math.PI * 2);
        for (let j = 0; j < ringCount; j++) {
          // å½“å‰ç¯çš„é«˜åº¦ï¼ˆæ›´è‡ªç”±éšæœºï¼‰
          const t = (j + Math.random() * 0.6) / ringCount;
          let yLocal = t * height - height / 2;
          yLocal += (Math.random() - 0.5) * 0.22; // é«˜åº¦æŠ–åŠ¨æ›´æ˜æ˜¾ï¼Œé¿å…æ•´é½
          const localRadius = radius * (1 - (yLocal + height / 2) / height * 0.85);
          const bulbsPerRing = 8 + Math.floor(Math.random() * 8); // æ¯ç¯ 8-15 ä¸ª
          for (let k = 0; k < bulbsPerRing; k++) {
            let baseAngle = (k / bulbsPerRing) * Math.PI * 2;
            // 35% æ¦‚ç‡å¸å¼•åˆ°æŸä¸ªç°‡ä¸­å¿ƒé™„è¿‘ï¼Œå½¢æˆâ€œç°‡çŠ¶â€æ•ˆæœ
            if (Math.random() < 0.35) {
              const center = clusterCenters[Math.floor(Math.random() * clusterCenters.length)];
              baseAngle = center + (Math.random() - 0.5) * 0.35;
            }
            const angle = baseAngle + (idx * 0.12) + (Math.random() - 0.5) * 0.18;
            const radiusJitter = (Math.random() - 0.5) * 0.25 * localRadius;
            const x = Math.cos(angle) * (localRadius + radiusJitter);
            const z = Math.sin(angle) * (localRadius + radiusJitter);
            const bulbGeo = new THREE.SphereGeometry(0.18 + Math.random() * 0.06, 12, 12);
            const color = bulbColors[(k + j + idx) % bulbColors.length];
            const bulbMat = new THREE.MeshPhysicalMaterial({ color, emissive: color, emissiveIntensity: 0.65, roughness: 0.25, metalness: 0.8 });
            const bulb = new THREE.Mesh(bulbGeo, bulbMat);
            bulb.position.set(mesh.position.x + x, mesh.position.y + yLocal, mesh.position.z + z);
            bulb.castShadow = true;
            treeGroup.add(bulb);
            bulbs.push({ mesh: bulb, baseIntensity: 0.6 + Math.random() * 0.28, phase: Math.random() * Math.PI * 2 });
          }
        }
      });

      // é¢å¤–è£…é¥°ï¼šå½©è‰²å°å¶å­ã€å°èŠ±èŠ±ã€å°è‹¹æœã€å°æ˜Ÿæ˜Ÿï¼ˆå¸¦äº®æ™¶æ™¶æ•ˆæœï¼‰
      const ornamentGroup = new THREE.Group();
      treeGroup.add(ornamentGroup);

      function makeLeafTexture() {
        const c = document.createElement('canvas'); c.width = c.height = 64; const ctx = c.getContext('2d');
        ctx.clearRect(0,0,64,64); ctx.translate(32,32); ctx.rotate((Math.random()-0.5)*0.6);
        const g = ctx.createRadialGradient(0,0,10,0,0,28);
        g.addColorStop(0,'rgba(255,255,255,0.95)');
        g.addColorStop(1,'rgba(255,255,255,0.0)');
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.ellipse(0,0,22,10,0,0,Math.PI*2); ctx.fill();
        const tex = new THREE.CanvasTexture(c); tex.colorSpace = THREE.SRGBColorSpace; return tex;
      }
      function makeColoredFlowerTexture(colorHex) {
        const c = document.createElement('canvas'); c.width = c.height = 64; const ctx = c.getContext('2d');
        ctx.clearRect(0,0,64,64); ctx.translate(32,32);
        const col = `#${colorHex.toString(16).padStart(6,'0')}`;
        ctx.fillStyle = col;
        for (let i=0;i<6;i++) { ctx.rotate(Math.PI/3); ctx.beginPath(); ctx.ellipse(16,0,8,3,0,0,Math.PI*2); ctx.fill(); }
        const tex = new THREE.CanvasTexture(c); tex.colorSpace = THREE.SRGBColorSpace; return tex;
      }

      const leafColors = [0x9cffb8, 0xa7ffda, 0xfff0a6, 0xffa3c8];
      const flowerColors = [0xff5fa2, 0xffd76b, 0x7cdfff, 0xffffff];
      const smallStarColors = [0xfff38a, 0xaad6ff, 0xffa6c1];
      const giftColors = [0xff6b6b, 0x6fd3ff, 0xffc45c, 0xb588ff, 0x7ce8a0];
      // é¦™è•‰ï¼ˆMeshï¼‰ï¼šç”¨ TubeGeometry æ²¿æ›²çº¿ç”Ÿæˆï¼Œå¸¦é»„è‰²è‡ªå‘å…‰
      function createBananaMesh() {
        const path = new THREE.CatmullRomCurve3([
          new THREE.Vector3(-0.4, 0.0, 0.0),
          new THREE.Vector3(-0.1, 0.15, 0.05),
          new THREE.Vector3(0.2, 0.22, 0.0),
          new THREE.Vector3(0.45, 0.05, -0.03)
        ]);
        const geo = new THREE.TubeGeometry(path, 32, 0.06, 12, false);
        const mat = new THREE.MeshPhysicalMaterial({ color: 0xffe36b, emissive: 0xffd34f, emissiveIntensity: 0.65, roughness: 0.4, metalness: 0.2 });
        const banana = new THREE.Mesh(geo, mat);
        banana.rotation.y = Math.random()*Math.PI*2;
        banana.castShadow = true;
        return banana;
      }

      // å½©è‰²ç³–æœçº¹ç†ï¼ˆåŒ…è£¹ç³–ä¸æ¡çº¹ï¼‰ï¼Œå°½é‡ä½¿ç”¨è“ã€å¤©è“ä¸å…¶ä»–å†·è‰²ï¼›ä»…å°‘é‡ç²‰è‰²
      function makeCandyTexture(baseHex = 0x6fd3ff, accentHex = 0xffffff, variant = 0) {
        const c = document.createElement('canvas'); c.width = c.height = 64; const ctx = c.getContext('2d');
        ctx.clearRect(0,0,64,64);
        ctx.translate(32,32);
        // åŒ…è£¹ç³–ä¸»ä½“
        ctx.save();
        ctx.rotate((Math.random()-0.5)*0.2);
        const base = `#${baseHex.toString(16).padStart(6,'0')}`;
        const accent = `#${accentHex.toString(16).padStart(6,'0')}`;
        const grad = ctx.createLinearGradient(-18,-12,18,12);
        grad.addColorStop(0, base);
        grad.addColorStop(1, base);
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.ellipse(0,0,18,10,0,0,Math.PI*2); ctx.fill();
        // æ¡çº¹
        ctx.lineWidth = 3.0; ctx.strokeStyle = accent; ctx.globalAlpha = 0.9;
        for (let i=-12;i<=12;i+=6) { ctx.beginPath(); ctx.moveTo(i,-8); ctx.lineTo(i+8,8); ctx.stroke(); }
        // äº®æ–‘
        ctx.globalAlpha = 0.6; ctx.fillStyle = 'rgba(255,255,255,0.65)';
        ctx.beginPath(); ctx.ellipse(-6,-2,6,3,0,0,Math.PI*2); ctx.fill();
        ctx.restore();
        // ä¸¤ç«¯åŒ…è£¹çº¸ï¼ˆç¿…çŠ¶ï¼‰
        ctx.globalAlpha = 0.85; ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.beginPath(); ctx.moveTo(-18,0); ctx.quadraticCurveTo(-26,-4,-30,-10); ctx.lineTo(-28,0); ctx.quadraticCurveTo(-26,6,-18,10); ctx.closePath(); ctx.fill();
        ctx.beginPath(); ctx.moveTo(18,0); ctx.quadraticCurveTo(26,-4,30,-10); ctx.lineTo(28,0); ctx.quadraticCurveTo(26,6,18,10); ctx.closePath(); ctx.fill();
        const tex = new THREE.CanvasTexture(c); tex.colorSpace = THREE.SRGBColorSpace; return tex;
      }
      const candyColors = [0x2fb8ff, 0x6fd3ff, 0x79ffcc, 0xfff06b, 0x9b7aff, 0xff9f5b, 0xffffff]; // ä»¥è“/å¤©è“ä¸ºä¸»
      const candyAccentColors = [0xffffff, 0xeaf6ff, 0xfff6e6, 0xd6e9ff];

      function addOrnamentsOnLayer(mesh, radius, height) {
        const count = 72 + Math.floor(Math.random()*56); // æ¯å±‚éšæœº 72-128 ä¸ªï¼ˆæ›´å¯†é›†ï¼Œè¦†ç›–ç²‰è‰²ï¼‰
        for (let i=0;i<count;i++) {
          const t = Math.random();
          const yLocal = (t * 0.9 + 0.05) * height - height/2 + (Math.random()-0.5)*0.22;
          const ang = Math.random()*Math.PI*2;
          const r = radius * (1 - (yLocal + height/2)/height * 0.9) * (1 + (Math.random()-0.5)*0.12);
          const pos = new THREE.Vector3(mesh.position.x + Math.cos(ang)*r, mesh.position.y + yLocal, mesh.position.z + Math.sin(ang)*r);
          const typePick = Math.random();
          if (typePick < 0.18) {
            // å¶å­ï¼ˆSpriteï¼Œè½»å¾®å‘å…‰æ„Ÿï¼‰
            const tex = makeLeafTexture();
            const mat = new THREE.SpriteMaterial({ map: tex, color: leafColors[Math.floor(Math.random()*leafColors.length)], transparent: true, depthWrite: false, blending: THREE.AdditiveBlending });
            const spr = new THREE.Sprite(mat); spr.scale.setScalar(0.7 + Math.random()*0.5); spr.position.copy(pos).add(new THREE.Vector3((Math.random()-0.5)*0.25,(Math.random()-0.5)*0.2,(Math.random()-0.5)*0.2));
            ornamentGroup.add(spr);
          } else if (typePick < 0.56) {
            // å½©è‰²å°èŠ±ï¼ˆSpriteï¼‰
            const c = flowerColors[Math.floor(Math.random()*flowerColors.length)];
            const mat = new THREE.SpriteMaterial({ map: makeColoredFlowerTexture(c), color: 0xffffff, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending });
            const spr = new THREE.Sprite(mat); spr.scale.setScalar(0.75 + Math.random()*0.55); spr.position.copy(pos);
            ornamentGroup.add(spr);
          } else if (typePick < 0.78) {
            // å°è‹¹æœï¼ˆMeshï¼‰ï¼Œæœ‰å°æ
            const appleMat = new THREE.MeshPhysicalMaterial({ color: 0xff4a4a, emissive: 0xff4a4a, emissiveIntensity: 0.62, roughness: 0.4, metalness: 0.3 });
            const apple = new THREE.Mesh(new THREE.SphereGeometry(0.16, 12, 12), appleMat);
            apple.position.copy(pos);
            apple.castShadow = true; ornamentGroup.add(apple);
            bulbs.push({ mesh: apple, baseIntensity: 0.65 + Math.random()*0.25, phase: Math.random()*Math.PI*2 });
            const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.12, 8), new THREE.MeshStandardMaterial({ color: 0x5a3e2b }));
            stem.position.copy(pos.clone().add(new THREE.Vector3(0,0.15,0))); stem.rotation.z = (Math.random()-0.5)*0.6; ornamentGroup.add(stem);
          } else if (typePick < 0.94) {
            // å½©è‰²ç³–æœï¼ˆSpriteï¼‰
            const base = candyColors[Math.floor(Math.random()*candyColors.length)];
            // ä»…æå°æ¦‚ç‡ä½¿ç”¨ç²‰è‰²ï¼ˆè¦†ç›–æ ‘æœ¬æ¥çš„ç²‰è‰²ï¼‰
            const usePink = Math.random() < 0.05;
            const baseColor = usePink ? 0xff86c1 : base;
            const accent = candyAccentColors[Math.floor(Math.random()*candyAccentColors.length)];
            const mat = new THREE.SpriteMaterial({ map: makeCandyTexture(baseColor, accent), color: 0xffffff, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending, alphaTest: 0.08 });
            const spr = new THREE.Sprite(mat); spr.scale.setScalar(0.9 + Math.random()*0.4); spr.position.copy(pos);
            ornamentGroup.add(spr);
            // ç³–æœé«˜å…‰ï¼šåœ¨ç³–æœé™„è¿‘æ·»åŠ ä¸€ä¸ªå°å‹å‘å…‰ç‚¹ï¼Œå¢åŠ æ•´ä½“äº®åº¦ä½†ä¸è¿‡æ›
            const glintColor = new THREE.Color(baseColor).multiplyScalar(1.0).getHex();
            const glint = new THREE.Mesh(new THREE.SphereGeometry(0.06, 8, 8), new THREE.MeshStandardMaterial({ color: glintColor, emissive: glintColor, emissiveIntensity: 0.6 }));
            glint.position.copy(pos.clone().add(new THREE.Vector3((Math.random()-0.5)*0.08, (Math.random()-0.5)*0.08, (Math.random()-0.5)*0.08)));
            ornamentGroup.add(glint);
            bulbs.push({ mesh: glint, baseIntensity: 0.62 + Math.random()*0.22, phase: Math.random()*Math.PI*2 });
          } else if (typePick < 0.99) {
            // å°ç¤¼ç‰©ï¼ˆMeshï¼‰â€”â€”ç¤¼ç‰©æœ¬ä½“æµ…æµ…åŒè‰²è‡ªå‘å…‰ + å°å…‰æ™•
            const color = giftColors[Math.floor(Math.random()*giftColors.length)];
            const gSize = 0.22 + Math.random()*0.08; // ç¤¼ç‰©æ›´å¤§
            const box = new THREE.Mesh(new THREE.BoxGeometry(gSize, gSize, gSize), new THREE.MeshPhysicalMaterial({ color, emissive: mixHexColor(color, 0xffffff, 0.72), emissiveIntensity: 0.28, roughness: 0.5, metalness: 0.2 }));
            box.position.copy(pos);
            box.castShadow = true; ornamentGroup.add(box);
            const haloCol = mixHexColor(color, 0xffffff, 0.84);
            const halo = new THREE.Sprite(new THREE.SpriteMaterial({ map: makeHaloTexture('#ffffff'), color: haloCol, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending }));
            halo.scale.setScalar(0.22 + Math.random()*0.12);
            halo.position.copy(pos.clone().add(new THREE.Vector3(0, 0.02, 0)));
            ornamentGroup.add(halo);
            const thick = Math.max(0.016, gSize*0.08);
            const height = gSize*1.05;
      const ribbon1 = new THREE.Mesh(new THREE.BoxGeometry(thick, height, gSize), new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.56 }));
      const ribbon2 = new THREE.Mesh(new THREE.BoxGeometry(gSize, height, thick), new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.56 }));
            ribbon1.position.copy(pos.clone().add(new THREE.Vector3(0,0.0,0))); ribbon2.position.copy(pos.clone().add(new THREE.Vector3(0,0.0,0)));
            ornamentGroup.add(ribbon1); ornamentGroup.add(ribbon2);
            // è®©ç¤¼ç‰©è½»å¾®å‘å…‰å‚ä¸é—ªçƒï¼šä»¥ä¸å¸¦ä¸º flicker å¯¹è±¡
            bulbs.push({ mesh: ribbon1, baseIntensity: 0.65 + Math.random()*0.25, phase: Math.random()*Math.PI*2 });
            bulbs.push({ mesh: ribbon2, baseIntensity: 0.65 + Math.random()*0.25, phase: Math.random()*Math.PI*2 });
          } else {
            // å°æ˜Ÿæ˜Ÿï¼ˆMeshï¼‰
            const sShape = createStarShape(0.25, 0.12, 5);
            const sGeo = new THREE.ExtrudeGeometry(sShape, { depth: 0.08, bevelEnabled: true, bevelSegments: 1, bevelThickness: 0.03, bevelSize: 0.03 });
            const c = smallStarColors[Math.floor(Math.random()*smallStarColors.length)];
            const sMat = new THREE.MeshPhysicalMaterial({ color: c, emissive: c, emissiveIntensity: 0.55, roughness: 0.35, metalness: 0.4 });
            const sMesh = new THREE.Mesh(sGeo, sMat);
            sMesh.position.copy(pos); sMesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
            sMesh.castShadow = true; ornamentGroup.add(sMesh);
            bulbs.push({ mesh: sMesh, baseIntensity: 0.65 + Math.random()*0.25, phase: Math.random()*Math.PI*2 });
          }
        }
      }

      foliageCones.forEach(({ mesh, radius, height }) => addOrnamentsOnLayer(mesh, radius, height));

      // ç²’å­å…‰æ™•ä¸èºæ—‹å…‰å¸¦ï¼ˆPoints ç²’å­ç³»ç»Ÿï¼‰
      function makePointTexture() {
        const c = document.createElement('canvas'); c.width = c.height = 64; const ctx = c.getContext('2d');
        const g = ctx.createRadialGradient(32,32,6,32,32,30);
        g.addColorStop(0,'rgba(255,255,255,1.0)');
        g.addColorStop(0.4,'rgba(255,255,255,0.25)');
        g.addColorStop(1,'rgba(255,255,255,0.0)');
        ctx.fillStyle = g; ctx.beginPath(); ctx.arc(32,32,30,0,Math.PI*2); ctx.fill();
        const tex = new THREE.CanvasTexture(c); tex.colorSpace = THREE.SRGBColorSpace; return tex;
      }
      // ä¼°ç®—æŸé«˜åº¦å¤„çš„æ ‘åŠå¾„ï¼ˆåŸºäºæ¯å±‚é”¥ä½“çš„å±€éƒ¨åŠå¾„å‡½æ•°ï¼‰
      function treeRadiusAtY(y) {
        let best = 0;
        for (const { mesh, radius, height } of foliageCones) {
          const yLocal = y - mesh.position.y; // ç›¸å¯¹å½“å‰é”¥ä½“ä¸­å¿ƒçš„é«˜åº¦
          if (yLocal >= -height/2 && yLocal <= height/2) {
            const localR = radius * (1 - (yLocal + height/2)/height * 0.85);
            best = Math.max(best, localR);
          }
        }
        return best * (typeof TREE_SCALE !== 'undefined' ? TREE_SCALE : 1);
      }
      // 1) ç²’å­å…‰æ™•ï¼ˆæ˜Ÿå…‰äº‘ï¼‰
const haloCount = 820;
      const haloGeo = new THREE.BufferGeometry();
      const haloPos = new Float32Array(haloCount * 3);
      const haloCol = new Float32Array(haloCount * 3);
      const haloColBase = new Float32Array(haloCount * 3);
      const haloPhase = new Float32Array(haloCount);
      const yMin = trunk.position.y + 0.8;
      const yMax = topY - 0.6;
      for (let i=0;i<haloCount;i++) {
        const y = yMin + Math.random() * (yMax - yMin);
        const rBase = treeRadiusAtY(y);
        const r = rBase * (1.12 + Math.random() * 0.28);
        const ang = Math.random()*Math.PI*2;
        haloPos[i*3+0] = Math.cos(ang)*r + (Math.random()-0.5)*0.15;
        haloPos[i*3+1] = y + (Math.random()-0.5)*0.25;
        haloPos[i*3+2] = Math.sin(ang)*r + (Math.random()-0.5)*0.15;
        // æš–é‡‘-ç²‰ç´«æ¸å˜ï¼ˆéšæœºæƒé‡ï¼‰
        const gold = new THREE.Color(0xffd34f);
        const pinkvio = new THREE.Color(0xcc88ff);
        const t = Math.random()*0.6 + 0.2; // åä¸­é—´åŒºé—´ï¼Œé¿å…è¿‡åˆ†åå‘æŸä¸€è‰²
        const cMix = gold.clone().lerp(pinkvio, t);
        haloCol[i*3+0] = cMix.r; haloCol[i*3+1] = cMix.g; haloCol[i*3+2] = cMix.b;
        haloColBase[i*3+0] = cMix.r; haloColBase[i*3+1] = cMix.g; haloColBase[i*3+2] = cMix.b;
        haloPhase[i] = Math.random()*Math.PI*2;
      }
      haloGeo.setAttribute('position', new THREE.BufferAttribute(haloPos,3));
      haloGeo.setAttribute('color', new THREE.BufferAttribute(haloCol,3));
      const haloMatPts = new THREE.PointsMaterial({
        map: makePointTexture(), size: 0.18, sizeAttenuation: true, transparent: true,
        depthWrite: false, blending: THREE.AdditiveBlending, vertexColors: true, opacity: 0.9
      });
      const treeHalo = new THREE.Points(haloGeo, haloMatPts);
      treeHalo.frustumCulled = false;
      treeGroup.add(treeHalo);

      // 2) èºæ—‹çŠ¶ç¯å½¢ç²’å­å…‰å¸¦
const ringCount = 480;
      const ringGeo = new THREE.BufferGeometry();
      const ringPos = new Float32Array(ringCount * 3);
      const ringCol = new Float32Array(ringCount * 3);
      const ringColBase = new Float32Array(ringCount * 3);
      const ringPhase = new Float32Array(ringCount);
      const ringT = new Float32Array(ringCount);
      const ringPhi0 = new Float32Array(ringCount);
      const turns = 6.0; // èºæ—‹åœˆæ•°
      for (let i=0;i<ringCount;i++) {
        const t = Math.random();
        ringT[i] = t;
        ringPhi0[i] = Math.random()*Math.PI*2;
        const y = yMin + t * (yMax - yMin);
        const r = treeRadiusAtY(y) * 1.05;
        const phi = ringPhi0[i];
        ringPos[i*3+0] = Math.cos(phi)*r;
        ringPos[i*3+1] = y;
        ringPos[i*3+2] = Math.sin(phi)*r;
        // ç²‰ç´«åˆ°æš–é‡‘çš„æ¸å˜ï¼ˆä¸é«˜åº¦ç›¸å…³ï¼Œè¶Šé«˜è¶Šæš–é‡‘ï¼‰
        const cLow = new THREE.Color(0xcc88ff);
        const cHigh = new THREE.Color(0xffd34f);
        const mix = t*0.7 + 0.2;
        const cMix = cLow.clone().lerp(cHigh, mix);
        ringCol[i*3+0] = cMix.r; ringCol[i*3+1] = cMix.g; ringCol[i*3+2] = cMix.b;
        ringColBase[i*3+0] = cMix.r; ringColBase[i*3+1] = cMix.g; ringColBase[i*3+2] = cMix.b;
        ringPhase[i] = Math.random()*Math.PI*2;
      }
      ringGeo.setAttribute('position', new THREE.BufferAttribute(ringPos,3));
      ringGeo.setAttribute('color', new THREE.BufferAttribute(ringCol,3));
      const ringMat = new THREE.PointsMaterial({
        map: makePointTexture(), size: 0.22, sizeAttenuation: true, transparent: true,
        depthWrite: false, blending: THREE.AdditiveBlending, vertexColors: true, opacity: 0.95
      });
      const ringPoints = new THREE.Points(ringGeo, ringMat);
      ringPoints.frustumCulled = false;
      treeGroup.add(ringPoints);

      // ç²’å­åŠ¨æ•ˆæ§åˆ¶ä¸äº¤äº’ï¼šå•å‡»åˆ‡æ¢é€Ÿåº¦/æš‚åœï¼ˆ1.0 â†’ 0.4 â†’ æš‚åœ â†’ 1.0ï¼‰
      const particleControl = { speedScale: 1.0, paused: false };
      renderer.domElement.addEventListener('pointerdown', () => {
        if (particleControl.paused) { particleControl.paused = false; particleControl.speedScale = 1.0; }
        else if (particleControl.speedScale > 0.5) { particleControl.speedScale = 0.4; }
        else { particleControl.paused = true; }
      });

      class SpiralCurve extends THREE.Curve {
        constructor(yStart, yEnd, turns, maxRadius) { super(); this.yStart = yStart; this.yEnd = yEnd; this.turns = turns; this.maxRadius = maxRadius; }
        getPoint(t) {
          const y = this.yStart + (this.yEnd - this.yStart) * t;
          const angle = t * Math.PI * 2 * this.turns;
          const norm = (y - this.yStart) / (this.yEnd - this.yStart);
          const r = this.maxRadius * (1 - norm * 0.85) * 0.88;
          return new THREE.Vector3(Math.cos(angle) * r, y, Math.sin(angle) * r);
        }
      }
      const spiral = new SpiralCurve(trunk.position.y + 0.8, topY - 0.8, 5.5, baseRadius * 0.75);
      const tubeGeo = new THREE.TubeGeometry(spiral, 500, 0.08, 16, false);
      const tubeMat = new THREE.MeshPhysicalMaterial({ color: 0xeaeaea, emissive: 0x000000, emissiveIntensity: 0.0, roughness: 0.5, metalness: 0.1 });
      const garland = new THREE.Mesh(tubeGeo, tubeMat);
      garland.castShadow = true;
      treeGroup.add(garland);

      const lightGroup = new THREE.Group();
      const lightColors = [0xffffff, 0xffe6a8, 0xffb3d1, 0xfff5f5];
      const spiralPoints = 90;
      for (let i = 0; i <= spiralPoints; i++) {
        const t = i / spiralPoints;
        const p = spiral.getPoint(t);
        const bulbGeo = new THREE.SphereGeometry(0.12, 10, 10);
        const c = lightColors[i % lightColors.length];
        const bulbMat = new THREE.MeshStandardMaterial({ color: c, emissive: c, emissiveIntensity: 0.9 });
        const bulb = new THREE.Mesh(bulbGeo, bulbMat);
        bulb.position.copy(p);
        bulb.castShadow = false;
        lightGroup.add(bulb);
      }
      treeGroup.add(lightGroup);

      scene.add(treeGroup);

      // â€”â€” åˆ†å¸ƒå‡è¡¡ï¼šåœåœ¨æ ‘ä¸Šçš„è´è¶ï¼ˆæŒ‰å±‚å‡åŒ€è§’åº¦ï¼Œä¿ç•™è½»æ‰°åŠ¨ï¼‰
      function rebalancePerchedButterfliesEvenly({ angleNoise = 0.18, radiusNoise = 0.06 } = {}) {
        const golden = Math.PI * (3 - Math.sqrt(5));
        const ranges = foliageCones.map((layer, idx) => ({ idx, yMin: layer.mesh.position.y - layer.height/2, yMax: layer.mesh.position.y + layer.height/2 }));
        const perch = butterflies.filter(b => b.mode === 'perch');
        // å°†åœé©»è´è¶æŒ‰æ‰€åœ¨å±‚åˆ†ç»„
        const grouped = new Map();
        perch.forEach(b => {
          const y = b.group.position.y;
          const layer = ranges.find(r => y >= r.yMin && y <= r.yMax);
          if (!layer) return;
          const arr = grouped.get(layer.idx) || []; arr.push(b); grouped.set(layer.idx, arr);
        });
        grouped.forEach((items, idx) => {
          const { mesh, radius, height } = foliageCones[idx];
          items.forEach((b, i) => {
            const ang = (i * golden) % (Math.PI * 2) + (Math.random()-0.5) * angleNoise;
            const yLocal = THREE.MathUtils.clamp(b.group.position.y - mesh.position.y, -height/2, height/2);
            const baseR = radius * (1 - (yLocal + height/2) / height * 0.92);
            const localR = baseR * (1 + (Math.random()-0.5) * radiusNoise);
            const x = mesh.position.x + Math.cos(ang) * localR;
            const z = mesh.position.z + Math.sin(ang) * localR;
            b.group.position.set(x, mesh.position.y + yLocal, z);
          });
        });
      }

      // â€”â€” æ‘„åƒæœºé€‚é…ï¼šæ ¹æ®æ ‘çš„åŒ…å›´ç›’è‡ªåŠ¨å±…ä¸­ä¸è·ç¦»ï¼Œç¡®ä¿æ•´æ£µæ ‘å¯è§
      function fitCameraToTreeGroup({ margin = 1.14 } = {}) {
        const box = new THREE.Box3().setFromObject(treeGroup);
        const size = new THREE.Vector3(); box.getSize(size);
        const center = new THREE.Vector3(); box.getCenter(center);
        // ä¿æŒå½“å‰è§†è§’æ–¹å‘ï¼Œè°ƒæ•´è·ç¦»
        const fov = THREE.MathUtils.degToRad(camera.fov);
        const halfY = size.y * 0.5 * margin;
        const halfX = size.x * 0.5 * margin;
        // å–æ›´ä¸¥æ ¼çš„çº¦æŸï¼ˆæ¨ªå‘æˆ–çºµå‘ï¼‰ï¼Œä¼°ç®—æ‰€éœ€è·ç¦»
        const vDist = halfY / Math.tan(fov / 2);
        const hDist = halfX / Math.tan(Math.atan((camera.aspect) * Math.tan(fov/2)));
        const dist = Math.max(vDist, hDist);
        const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
        const newPos = center.clone().sub(dir.normalize().multiplyScalar(dist + size.z));
        camera.position.copy(newPos);
        controls.target.copy(center);
        controls.update();
      }

      // è®¡ç®—æŸä¸ªä¸–ç•Œåæ ‡çš„å±å¹• Yï¼ˆpxï¼‰ï¼Œç”¨äºçº¦æŸå³ä¾§æ–‡å­—ä¸é«˜äºç¬¬å››å±‚
      function worldYToScreenY(yWorld) {
        const v = new THREE.Vector3(0, yWorld, 0);
        v.project(camera);
        const y = (v.y * 0.5 + 0.5) * window.innerHeight;
        return y;
      }
      // è·å–æ ‘åœ¨å±å¹•ä¸Šçš„çŸ©å½¢èŒƒå›´ï¼ˆpxï¼‰ï¼Œç”¨äºé™åˆ¶è¦†ç›–å±‚è´è¶åªåœ¨â€œåŸæœ¬èŒƒå›´ä¹‹å¤–â€ç”Ÿæˆ
      function getTreeScreenRect() {
        const box = new THREE.Box3().setFromObject(treeGroup);
        const corners = [
          new THREE.Vector3(box.min.x, box.min.y, box.min.z),
          new THREE.Vector3(box.min.x, box.min.y, box.max.z),
          new THREE.Vector3(box.min.x, box.max.y, box.min.z),
          new THREE.Vector3(box.min.x, box.max.y, box.max.z),
          new THREE.Vector3(box.max.x, box.min.y, box.min.z),
          new THREE.Vector3(box.max.x, box.min.y, box.max.z),
          new THREE.Vector3(box.max.x, box.max.y, box.min.z),
          new THREE.Vector3(box.max.x, box.max.y, box.max.z),
        ];
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        corners.forEach(v => {
          v.project(camera);
          const x = (v.x * 0.5 + 0.5) * window.innerWidth;
          const y = (-v.y * 0.5 + 0.5) * window.innerHeight;
          minX = Math.min(minX, x); maxX = Math.max(maxX, x);
          minY = Math.min(minY, y); maxY = Math.max(maxY, y);
        });
        return { minX, maxX, minY, maxY };
      }
      // æ ‘æ•´ä½“æ”¾å¤§ 1.5 å€
      treeGroup.scale.setScalar(TREE_SCALE);

      // äº®è“ä¸å¤©è“â€œæ¢¦è¶â€â€”â€”åœ¨æ ‘å‘¨å›´é£èˆä¸åœé©»ï¼ˆè¯¦ç»†ç»“æ„ç‰ˆï¼šå‰ç¿…/åç¿…ã€ç¿…è„‰ã€çº¹ç†ä¸è™¹å½©ï¼‰
      function makeButterflyWingTexture({
        type = 'fore',            // 'fore' å‰ç¿… | 'hind' åç¿…
        baseInner = 0x144c8a,     // åŸºéƒ¨æ·±è‰²
        baseOuter = 0x6fd3ff,     // è¾¹ç¼˜æµ…è‰²
        veinColor = 'rgba(255,200,80,0.85)', // é‡‘è‰²ç¿…è„‰
        rimDot = 'rgba(255,255,255,0.9)',    // å¤–ç¼˜ç™½è‰²ç¢ç‚¹
        windowAlpha = 0.15        // é€æ˜â€œç¿…çª—â€å¼ºåº¦
      } = {}) {
        const c = document.createElement('canvas'); c.width = c.height = 128; const ctx = c.getContext('2d');
        ctx.clearRect(0,0,128,128);
        ctx.translate(28,64); // å·¦ä¾§è¿‘èº«ä½“å¤„ä¸ºæ¢è½´

        // 1) å½¢çŠ¶ï¼šå‰ç¿…æ›´ç‹­é•¿å°–ã€åç¿…æ›´åœ†æ¶¦ä¸”å¯å¸¦å°¾çª
        ctx.beginPath();
        ctx.moveTo(0,0);
        if (type === 'fore') {
          ctx.bezierCurveTo(36,-40,84,-18,92,8); // ä¸Šç¼˜
          ctx.bezierCurveTo(72,6,48,28,6,16);    // ä¸‹ç¼˜å›åˆ°æ¢è½´
        } else {
          ctx.bezierCurveTo(28,-30,72,-16,86,6);
          ctx.bezierCurveTo(60,14,42,34,10,24);
          // å°¾çªï¼ˆè½»å¾®ï¼‰
          ctx.quadraticCurveTo(30,36,40,44);
          ctx.quadraticCurveTo(18,36,6,18);
        }
        ctx.closePath();

        // 2) åº•è‰²æ¸å˜ï¼ˆåŸºéƒ¨æ·±ã€è¾¹ç¼˜æµ…ï¼Œå¸¦ç å…‰ï¼‰
        const grad = ctx.createLinearGradient(0,0,96,0);
        const inner = `#${baseInner.toString(16).padStart(6,'0')}`;
        const outer = `#${baseOuter.toString(16).padStart(6,'0')}`;
        grad.addColorStop(0, inner);
        grad.addColorStop(1, outer);
        ctx.fillStyle = grad;
        ctx.fill();

        // 3) é€æ˜â€œç¿…çª—â€ä¸è™¹å½©ï¼šåœ¨å±€éƒ¨åŒºåŸŸå‡é€æ˜å¹¶å åŠ æ·¡è“/æ·¡ç´«
        ctx.globalCompositeOperation = 'destination-out';
        ctx.globalAlpha = windowAlpha;
        for (let i=0;i<2;i++) {
          ctx.beginPath(); ctx.ellipse(40+Math.random()*20, -4+Math.random()*10, 10, 6, Math.random()*0.3, 0, Math.PI*2); ctx.fill();
        }
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 0.35;
        ctx.fillStyle = 'rgba(150,180,255,0.55)';
        ctx.beginPath(); ctx.ellipse(54, 8, 22, 10, 0.2, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1.0;

        // 4) ç¿…è„‰ï¼ˆç½‘çŠ¶ï¼‰ï¼šä¸»è„‰ + åˆ†æ”¯è„‰
        ctx.strokeStyle = veinColor; ctx.lineWidth = 2.2; ctx.lineCap = 'round';
        const mainVeins = [
          {ax:0, ay:0, bx:84, by:-2},
          {ax:0, ay:0, bx:78, by:14},
          {ax:0, ay:0, bx:62, by:28}
        ];
        mainVeins.forEach(v => { ctx.beginPath(); ctx.moveTo(v.ax, v.ay); ctx.lineTo(v.bx, v.by); ctx.stroke(); });
        ctx.lineWidth = 1.6;
        for (let i=0;i<5;i++) {
          ctx.beginPath(); ctx.moveTo(20+ i*10, -8 + i*4); ctx.lineTo(42 + i*8, 18 + i*2); ctx.stroke();
        }

        // 5) å¤–ç¼˜ç¢ç‚¹ï¼ˆç™½è‰²ç‚¹ç¼€ï¼‰
        ctx.fillStyle = rimDot;
        for (let i=0;i<18;i++) {
          const ex = 72 + Math.random()*24; const ey = -4 + Math.random()*20; ctx.beginPath(); ctx.arc(ex, ey, 1.8, 0, Math.PI*2); ctx.fill();
        }

        // é«˜å…‰çº¿æ¡
        ctx.strokeStyle = 'rgba(255,255,255,0.65)'; ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.moveTo(8,6); ctx.quadraticCurveTo(40,-4,70,10); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(10,10); ctx.quadraticCurveTo(42,12,64,20); ctx.stroke();

        const tex = new THREE.CanvasTexture(c); tex.colorSpace = THREE.SRGBColorSpace; tex.anisotropy = 8; return tex;
      }

      const BUTTERFLY_SCALE = 1.5; // è´è¶æ•´ä½“æ”¾å¤§ 1.5 å€
      function createButterfly(colorHex = 0x6fd3ff, scale = 0.6, opts = {}) {
        const group = new THREE.Group();
        // å››ç¿¼æ¢è½´ï¼ˆå‰ç¿…/åç¿…ï¼‰
        const leftForePivot = new THREE.Group(); const rightForePivot = new THREE.Group();
        const leftHindPivot = new THREE.Group(); const rightHindPivot = new THREE.Group();
        // çº¹ç†
        const baseInner = opts.baseInner ?? 0x184c8a;
        const baseOuter = opts.baseOuter ?? colorHex;
        const texFore = makeButterflyWingTexture({ type:'fore', baseInner, baseOuter });
        const texHind = makeButterflyWingTexture({ type:'hind', baseInner, baseOuter });
        const matFore = new THREE.MeshStandardMaterial({ map: texFore, color: 0xffffff, transparent: true, side: THREE.DoubleSide, emissive: colorHex, emissiveIntensity: 0.55 });
        const matHind = new THREE.MeshStandardMaterial({ map: texHind, color: 0xffffff, transparent: true, side: THREE.DoubleSide, emissive: colorHex, emissiveIntensity: 0.6 });
        // æ›´é«˜ç»†åˆ†ç”¨äºâ€œè†œæ³¢çº¹â€
        const foreWingL = new THREE.Mesh(new THREE.PlaneGeometry(0.72, 0.52, 6, 6), matFore.clone()); foreWingL.position.x = 0.26;
        const foreWingR = new THREE.Mesh(new THREE.PlaneGeometry(0.72, 0.52, 6, 6), matFore.clone()); foreWingR.scale.x = -1; foreWingR.position.x = -0.26;
        const hindWingL = new THREE.Mesh(new THREE.PlaneGeometry(0.62, 0.48, 6, 6), matHind.clone()); hindWingL.position.x = 0.22; hindWingL.position.y = -0.02;
        const hindWingR = new THREE.Mesh(new THREE.PlaneGeometry(0.62, 0.48, 6, 6), matHind.clone()); hindWingR.scale.x = -1; hindWingR.position.x = -0.22; hindWingR.position.y = -0.02;
        leftForePivot.add(foreWingL); rightForePivot.add(foreWingR);
        leftHindPivot.add(hindWingL); rightHindPivot.add(hindWingR);
        leftForePivot.position.x = -0.065; rightForePivot.position.x = 0.065;
        leftHindPivot.position.x = -0.055; rightHindPivot.position.x = 0.055;
        // èº«ä½“ä¸è§¦è§’
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.03,0.38,12), new THREE.MeshStandardMaterial({ color: 0x224a7f, emissive: 0x1e6eff, emissiveIntensity: 0.4 }));
        body.rotation.z = Math.PI/2; body.position.y = 0.02;
        group.add(leftForePivot, rightForePivot, leftHindPivot, rightHindPivot, body);
        group.scale.setScalar(scale * BUTTERFLY_SCALE);
        return { group, leftForePivot, rightForePivot, leftHindPivot, rightHindPivot, foreWingL, foreWingR, hindWingL, hindWingR };
      }

      const butterflyAmbientGroup = new THREE.Group(); // å›´ç»•æ ‘é£
      scene.add(butterflyAmbientGroup);
      const butterflyPerchGroup = new THREE.Group(); // åœåœ¨æ ‘ä¸Š
      treeGroup.add(butterflyPerchGroup);
      const butterflies = [];
      function spawnButterflies(countAround = 50, countOnTree = 120) {
        const palette = [0x2fb8ff, 0x6fd3ff];
        for (let i=0;i<countAround;i++) {
          const color = palette[i % palette.length];
          const b = createButterfly(color, 0.68, { baseInner: 0x184c8a, baseOuter: color });
          const radius = 7 + Math.random()*5; const angle = Math.random()*Math.PI*2;
          const baseY = 4 + Math.random()*6; const flySpeed = 0.3 + Math.random()*0.5;
          const flapSpeed = 4.2 + Math.random()*2.0; const phase = Math.random()*Math.PI*2;
          b.group.position.set(Math.cos(angle)*radius, baseY, Math.sin(angle)*radius);
          b.group.rotation.y = -angle + Math.PI/2;
          butterflyAmbientGroup.add(b.group);
          butterflies.push({ mode:'around', group:b.group, leftForePivot:b.leftForePivot, rightForePivot:b.rightForePivot, leftHindPivot:b.leftHindPivot, rightHindPivot:b.rightHindPivot, radius, angle, baseY, flySpeed, flapSpeed, phase });
        }
        // åœé©»åœ¨æ ‘ä¸Šçš„è´è¶ï¼šéšæœºæ”¾åœ¨å„æ ‘å† å±‚è¡¨é¢
        foliageCones.forEach(({ mesh, radius, height }) => {
          const localCount = Math.floor(countOnTree / foliageCones.length);
          for (let i=0;i<localCount;i++) {
            const color = palette[(i + Math.floor(Math.random()*2)) % palette.length];
            const b = createButterfly(color, 0.58, { baseInner: 0x184c8a, baseOuter: color });
            const t = Math.random();
            const yLocal = (t*0.9 + 0.05)*height - height/2 + (Math.random()-0.5)*0.22;
            const ang = Math.random()*Math.PI*2;
            const r = radius * (1 - (yLocal + height/2)/height * 0.92) * (1 + (Math.random()-0.5)*0.12);
            const pos = new THREE.Vector3(mesh.position.x + Math.cos(ang)*r, mesh.position.y + yLocal, mesh.position.z + Math.sin(ang)*r);
            b.group.position.copy(pos);
            b.group.rotation.y = ang + Math.PI/2;
            butterflyPerchGroup.add(b.group);
            const flapSpeed = 3.6 + Math.random()*1.8; const phase = Math.random()*Math.PI*2; // æ›´æŸ”å’Œçš„æ‰‡åŠ¨
            butterflies.push({ mode:'perch', group:b.group, leftForePivot:b.leftForePivot, rightForePivot:b.rightForePivot, leftHindPivot:b.leftHindPivot, rightHindPivot:b.rightHindPivot, flapSpeed, phase });
          }
        });
      }
      // å¢é‡è¦†ç›–æ ‘çš„ç²‰è‰²æ°”è´¨ï¼šæ›´é«˜çš„è´è¶æ•°é‡
      spawnButterflies(50, 120);

      // é¢å¤–ï¼šå¢æ·»â€œé‡‘ç²‰è‰²â€è´è¶ï¼ˆæ•°é‡ç­‰åŒå‰ä¸€æ‰¹ï¼Œä»¥è¾¾åˆ°â€œå†å¢åŠ ä¸€å€é‡‘ç²‰è‰²â€çš„æ•ˆæœï¼‰
      function spawnGoldPinkButterflies(countAround = 50, countOnTree = 120) {
        const goldPinkInner = 0xffc85a; // é‡‘è‰²åŸºéƒ¨
        const goldPinkOuter = 0xff86c1; // ç²‰è‰²è¾¹ç¼˜
        const colorForEmissive = 0xffb3c6; // å‘å…‰é¢œè‰²ç•¥åç²‰é‡‘
        for (let i=0;i<countAround;i++) {
          const b = createButterfly(colorForEmissive, 0.7, { baseInner: goldPinkInner, baseOuter: goldPinkOuter });
          const radius = 7 + Math.random()*5; const angle = Math.random()*Math.PI*2;
          const baseY = 4 + Math.random()*6; const flySpeed = 0.32 + Math.random()*0.52;
          const flapSpeed = 4.0 + Math.random()*1.8; const phase = Math.random()*Math.PI*2;
          b.group.position.set(Math.cos(angle)*radius, baseY, Math.sin(angle)*radius);
          b.group.rotation.y = -angle + Math.PI/2;
          butterflyAmbientGroup.add(b.group);
          butterflies.push({ mode:'around', group:b.group, leftForePivot:b.leftForePivot, rightForePivot:b.rightForePivot, leftHindPivot:b.leftHindPivot, rightHindPivot:b.rightHindPivot, radius, angle, baseY, flySpeed, flapSpeed, phase });
        }
        foliageCones.forEach(({ mesh, radius, height }) => {
          const localCount = Math.floor(countOnTree / foliageCones.length);
          for (let i=0;i<localCount;i++) {
            const b = createButterfly(colorForEmissive, 0.6, { baseInner: goldPinkInner, baseOuter: goldPinkOuter });
            const t = Math.random();
            const yLocal = (t*0.9 + 0.05)*height - height/2 + (Math.random()-0.5)*0.22;
            const ang = Math.random()*Math.PI*2;
            const r = radius * (1 - (yLocal + height/2)/height * 0.92) * (1 + (Math.random()-0.5)*0.12);
            const pos = new THREE.Vector3(mesh.position.x + Math.cos(ang)*r, mesh.position.y + yLocal, mesh.position.z + Math.sin(ang)*r);
            b.group.position.copy(pos);
            b.group.rotation.y = ang + Math.PI/2;
            butterflyPerchGroup.add(b.group);
            const flapSpeed = 3.4 + Math.random()*1.6; const phase = Math.random()*Math.PI*2;
            butterflies.push({ mode:'perch', group:b.group, leftForePivot:b.leftForePivot, rightForePivot:b.rightForePivot, leftHindPivot:b.leftHindPivot, rightHindPivot:b.rightHindPivot, flapSpeed, phase });
          }
        });
      }
      spawnGoldPinkButterflies(50, 120);

      // ç»¿è‰²-é‡‘è‰²è´è¶ï¼ˆé¡¶ç«¯ 3/4/5 å±‚åŠ å¼ºï¼‰ï¼šä»ä¸Šå¾€ä¸‹çš„ç¬¬ 3ã€4ã€5 å±‚åŠ å¯†
      function spawnGreenGoldButterfliesOnLayers(layerIndices = [], aroundPerLayer = 22, perchPerLayer = 64) {
        const baseInner = 0x1b9f4a; // ç»¿è‰²åŸºéƒ¨
        const baseOuter = 0xffd34f; // é‡‘è‰²è¾¹ç¼˜
        const emissiveColor = 0xbde17a; // å‘å…‰åç»¿é‡‘
        layerIndices.forEach(idx => {
          const { mesh, radius, height } = foliageCones[idx] || {};
          if (!mesh) return;
          const yCenter = mesh.position.y;
          // ç¯ç»•é£è¡Œï¼ˆå±€éƒ¨åœˆç»•è¯¥å±‚ï¼‰
          for (let i=0;i<aroundPerLayer;i++) {
            const b = createButterfly(emissiveColor, 0.68, { baseInner, baseOuter });
            const rFly = radius * (1.1 + Math.random()*0.25);
            const angle = Math.random()*Math.PI*2;
            const baseY = yCenter + (Math.random()-0.5)*0.4;
            const flySpeed = 0.28 + Math.random()*0.45; const flapSpeed = 4.0 + Math.random()*1.8; const phase = Math.random()*Math.PI*2;
            b.group.position.set(Math.cos(angle)*rFly, baseY, Math.sin(angle)*rFly);
            b.group.rotation.y = -angle + Math.PI/2;
            butterflyAmbientGroup.add(b.group);
            butterflies.push({ mode:'around', group:b.group, leftForePivot:b.leftForePivot, rightForePivot:b.rightForePivot, leftHindPivot:b.leftHindPivot, rightHindPivot:b.rightHindPivot, radius:rFly, angle, baseY, flySpeed, flapSpeed, phase });
          }
          // åœé©»åœ¨è¯¥å±‚è¡¨é¢ï¼ˆæ›´å¯†é›†ï¼‰
          for (let i=0;i<perchPerLayer;i++) {
            const b = createButterfly(emissiveColor, 0.6, { baseInner, baseOuter });
            const t = Math.random();
            const yLocal = (t*0.9 + 0.05)*height - height/2 + (Math.random()-0.5)*0.22;
            const ang = Math.random()*Math.PI*2;
            const r = radius * (1 - (yLocal + height/2)/height * 0.92) * (1 + (Math.random()-0.5)*0.12);
            const pos = new THREE.Vector3(mesh.position.x + Math.cos(ang)*r, mesh.position.y + yLocal, mesh.position.z + Math.sin(ang)*r);
            b.group.position.copy(pos);
            b.group.rotation.y = ang + Math.PI/2;
            butterflyPerchGroup.add(b.group);
            const flapSpeed = 3.4 + Math.random()*1.6; const phase = Math.random()*Math.PI*2;
            butterflies.push({ mode:'perch', group:b.group, leftForePivot:b.leftForePivot, rightForePivot:b.rightForePivot, leftHindPivot:b.leftHindPivot, rightHindPivot:b.rightHindPivot, flapSpeed, phase });
          }
        });
      }
      // ä»ä¸Šå¾€ä¸‹ç¬¬ 3/4/5 å±‚ï¼šç´¢å¼•ä¸º length-3, length-2, length-1
      const top3to5 = [foliageCones.length-3, foliageCones.length-2, foliageCones.length-1];
      spawnGreenGoldButterfliesOnLayers(top3to5, 24, 72);

      // è¿™å‡ å±‚åŠ å¼ºâ€œæŒ‚åœ¨æ ‘ä¸Šçš„é—ªé—ªç¤¼ç‰©/ä¸å¸¦/èŠ±èŠ±/å½©ç¯â€
      function boostLayerDecorations(layerIndices = []) {
        const extraBulbColors = [0xffe06b, 0xa8ff7a, 0x7ad6ff, 0xffb3d1, 0xffffff];
        layerIndices.forEach(idx => {
          const { mesh, radius, height } = foliageCones[idx] || {};
          if (!mesh) return;
          // é¢å¤–å½©ç¯ï¼ˆçƒæ³¡ï¼‰
          const countBulb = 20;
          for (let i=0;i<countBulb;i++) {
            const t = Math.random();
            const yLocal = (t * 0.9 + 0.05) * height - height / 2 + (Math.random() - 0.5) * 0.22;
            const ang = Math.random()*Math.PI*2;
            const localRadius = radius * (1 - (yLocal + height / 2) / height * 0.85);
            const x = Math.cos(ang) * localRadius; const z = Math.sin(ang) * localRadius;
            const bulbGeo = new THREE.SphereGeometry(0.18 + Math.random()*0.06, 12, 12);
            const color = extraBulbColors[i % extraBulbColors.length];
            const bulbMat = new THREE.MeshPhysicalMaterial({ color, emissive: color, emissiveIntensity: 0.9, roughness: 0.25, metalness: 0.7 });
            const bulb = new THREE.Mesh(bulbGeo, bulbMat);
            bulb.position.set(mesh.position.x + x, mesh.position.y + yLocal, mesh.position.z + z);
            bulb.castShadow = false; treeGroup.add(bulb);
            bulbs.push({ mesh: bulb, baseIntensity: 0.72 + Math.random()*0.25, phase: Math.random()*Math.PI*2 });
          }
          // é¢å¤–ç¤¼ç‰©ä¸èŠ±èŠ±
          const countGift = 10; const countFlower = 18;
          for (let i=0;i<countGift;i++) {
            const color = giftColors[Math.floor(Math.random()*giftColors.length)];
            const gSize = 0.24 + Math.random()*0.1;
            const box = new THREE.Mesh(new THREE.BoxGeometry(gSize, gSize, gSize), new THREE.MeshPhysicalMaterial({ color, roughness: 0.5, metalness: 0.2 }));
            const t = Math.random();
            const yLocal = (t * 0.9 + 0.05) * height - height / 2 + (Math.random() - 0.5) * 0.22;
            const ang = Math.random()*Math.PI*2;
            const localRadius = radius * (1 - (yLocal + height / 2) / height * 0.9);
            const pos = new THREE.Vector3(mesh.position.x + Math.cos(ang)*localRadius, mesh.position.y + yLocal, mesh.position.z + Math.sin(ang)*localRadius);
            box.position.copy(pos); box.castShadow = true; ornamentGroup.add(box);
            const thick = Math.max(0.016, gSize*0.08); const heightB = gSize*1.05;
      const ribbon1 = new THREE.Mesh(new THREE.BoxGeometry(thick, heightB, gSize), new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.60 }));
      const ribbon2 = new THREE.Mesh(new THREE.BoxGeometry(gSize, heightB, thick), new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.60 }));
            ribbon1.position.copy(pos); ribbon2.position.copy(pos);
            ornamentGroup.add(ribbon1); ornamentGroup.add(ribbon2);
            bulbs.push({ mesh: ribbon1, baseIntensity: 0.72 + Math.random()*0.25, phase: Math.random()*Math.PI*2 });
            bulbs.push({ mesh: ribbon2, baseIntensity: 0.72 + Math.random()*0.25, phase: Math.random()*Math.PI*2 });
          }
          for (let i=0;i<countFlower;i++) {
            const c = flowerColors[Math.floor(Math.random()*flowerColors.length)];
            const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: makeColoredFlowerTexture(c), color: 0xffffff, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending }));
            const t = Math.random();
            const yLocal = (t * 0.9 + 0.05) * height - height / 2 + (Math.random() - 0.5) * 0.22;
            const ang = Math.random()*Math.PI*2;
            const localRadius = radius * (1 - (yLocal + height / 2) / height * 0.92) * (1 + (Math.random()-0.5)*0.12);
            spr.position.set(mesh.position.x + Math.cos(ang)*localRadius, mesh.position.y + yLocal, mesh.position.z + Math.sin(ang)*localRadius);
            spr.scale.setScalar(0.9 + Math.random()*0.5); ornamentGroup.add(spr);
          }
        });
      }
      boostLayerDecorations(top3to5);

      // åº•éƒ¨ä¸‰å±‚å†å¢åŠ â€œäº®é—ªé—ªçš„äº”é¢œå…­è‰²çš„ç¤¼ç‰©ã€èŠ±æœµã€æœå­ï¼ˆé¦™è•‰/è‹¹æœï¼‰â€
      function boostBottomLayersDecorations(layerIndices = []) {
        const extraBulbColors = [0xff5a5a, 0x5ac8ff, 0x5aff94, 0xffd34f, 0xb388ff, 0xffffff];
        layerIndices.forEach(idx => {
          const { mesh, radius, height } = foliageCones[idx] || {};
          if (!mesh) return;
          // å½©ç¯å¢åŠ 
          const countBulb = 28;
          for (let i=0;i<countBulb;i++) {
            const t = Math.random();
            const yLocal = (t * 0.9 + 0.05) * height - height / 2 + (Math.random() - 0.5) * 0.22;
            const ang = Math.random()*Math.PI*2;
            const localRadius = radius * (1 - (yLocal + height / 2) / height * 0.85);
            const x = Math.cos(ang) * localRadius; const z = Math.sin(ang) * localRadius;
            const bulbGeo = new THREE.SphereGeometry(0.2 + Math.random()*0.08, 12, 12);
            const color = extraBulbColors[i % extraBulbColors.length];
            const bulbMat = new THREE.MeshPhysicalMaterial({ color, emissive: color, emissiveIntensity: 1.0, roughness: 0.25, metalness: 0.7 });
            const bulb = new THREE.Mesh(bulbGeo, bulbMat);
            bulb.position.set(mesh.position.x + x, mesh.position.y + yLocal, mesh.position.z + z);
            bulb.castShadow = false; treeGroup.add(bulb);
            bulbs.push({ mesh: bulb, baseIntensity: 0.78 + Math.random()*0.25, phase: Math.random()*Math.PI*2 });
          }
          // ç¤¼ç‰©å¢é‡ï¼ˆæ›´å¤§ï¼‰
          const countGift = 14; const countFlower = 26; const countFruit = 22;
          for (let i=0;i<countGift;i++) {
            const color = giftColors[Math.floor(Math.random()*giftColors.length)];
            const gSize = 0.28 + Math.random()*0.12;
            const box = new THREE.Mesh(new THREE.BoxGeometry(gSize, gSize, gSize), new THREE.MeshPhysicalMaterial({ color, roughness: 0.5, metalness: 0.2 }));
            const t = Math.random(); const yLocal = (t * 0.9 + 0.05) * height - height / 2 + (Math.random() - 0.5) * 0.22; const ang = Math.random()*Math.PI*2;
            const localRadius = radius * (1 - (yLocal + height / 2) / height * 0.9);
            const pos = new THREE.Vector3(mesh.position.x + Math.cos(ang)*localRadius, mesh.position.y + yLocal, mesh.position.z + Math.sin(ang)*localRadius);
            box.position.copy(pos); box.castShadow = true; ornamentGroup.add(box);
            const thick = Math.max(0.018, gSize*0.08); const heightB = gSize*1.05;
      const ribbon1 = new THREE.Mesh(new THREE.BoxGeometry(thick, heightB, gSize), new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.64 }));
      const ribbon2 = new THREE.Mesh(new THREE.BoxGeometry(gSize, heightB, thick), new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.64 }));
            ribbon1.position.copy(pos); ribbon2.position.copy(pos);
            ornamentGroup.add(ribbon1); ornamentGroup.add(ribbon2);
            bulbs.push({ mesh: ribbon1, baseIntensity: 0.78 + Math.random()*0.25, phase: Math.random()*Math.PI*2 });
            bulbs.push({ mesh: ribbon2, baseIntensity: 0.78 + Math.random()*0.25, phase: Math.random()*Math.PI*2 });
          }
          // èŠ±æœµå¢é‡
          for (let i=0;i<countFlower;i++) {
            const c = flowerColors[Math.floor(Math.random()*flowerColors.length)];
            const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: makeColoredFlowerTexture(c), color: 0xffffff, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending }));
            const t = Math.random(); const yLocal = (t * 0.9 + 0.05) * height - height / 2 + (Math.random() - 0.5) * 0.22; const ang = Math.random()*Math.PI*2;
            const localRadius = radius * (1 - (yLocal + height / 2) / height * 0.92) * (1 + (Math.random()-0.5)*0.12);
            spr.position.set(mesh.position.x + Math.cos(ang)*localRadius, mesh.position.y + yLocal, mesh.position.z + Math.sin(ang)*localRadius);
            spr.scale.setScalar(1.0 + Math.random()*0.6); ornamentGroup.add(spr);
          }
          // æ°´æœå¢é‡ï¼ˆè‹¹æœ + é¦™è•‰ï¼‰
          for (let i=0;i<countFruit;i++) {
            const isBanana = Math.random() < 0.5;
            const t = Math.random(); const yLocal = (t * 0.9 + 0.05) * height - height / 2 + (Math.random() - 0.5) * 0.22; const ang = Math.random()*Math.PI*2;
            const localRadius = radius * (1 - (yLocal + height / 2) / height * 0.9) * (1 + (Math.random()-0.5)*0.12);
            const pos = new THREE.Vector3(mesh.position.x + Math.cos(ang)*localRadius, mesh.position.y + yLocal, mesh.position.z + Math.sin(ang)*localRadius);
            if (isBanana) {
              const banana = createBananaMesh(); banana.position.copy(pos);
              ornamentGroup.add(banana);
              bulbs.push({ mesh: banana, baseIntensity: 0.7 + Math.random()*0.25, phase: Math.random()*Math.PI*2 });
            } else {
              const appleMat = new THREE.MeshPhysicalMaterial({ color: 0xff4a4a, emissive: 0xff4a4a, emissiveIntensity: 0.68, roughness: 0.4, metalness: 0.3 });
              const apple = new THREE.Mesh(new THREE.SphereGeometry(0.18, 12, 12), appleMat);
              apple.position.copy(pos); apple.castShadow = true; ornamentGroup.add(apple);
              bulbs.push({ mesh: apple, baseIntensity: 0.72 + Math.random()*0.25, phase: Math.random()*Math.PI*2 });
            }
          }
        });
      }
      const bottom2 = [0,1];
      boostBottomLayersDecorations(bottom2);

      // å°†é¡¶ä¸Šä¸¤å±‚çš„è£…é¥°â€œç§»èµ°â€ï¼ˆéšè—ï¼‰ï¼Œå¹¶å¢å¼ºæœ€ä¸‹é¢ä¸¤å±‚çš„è£…é¥°ä¸äº®åº¦
      function computeLayerRange(idx) {
        const layer = foliageCones[idx];
        if (!layer) return null;
        const { mesh, height } = layer;
        return { yMin: mesh.position.y - height / 2, yMax: mesh.position.y + height / 2 };
      }

      function hideTopTwoLayersDecorations() {
        const n = foliageCones.length;
        const ranges = [computeLayerRange(n-1), computeLayerRange(n-2)].filter(Boolean);
        // éšè— ornamentGroup ä¸­ä½äºé¡¶ä¸¤å±‚èŒƒå›´çš„å¯¹è±¡
        ornamentGroup.children.forEach(obj => {
          const y = obj.position.y;
          if (ranges.some(r => y >= r.yMin && y <= r.yMax)) {
            obj.visible = false;
          }
        });
        // éšè—é¡¶ä¸¤å±‚èŒƒå›´å†…çš„å½©ç¯ï¼ˆbulbsï¼‰
        bulbs.forEach(b => {
          const y = b.mesh.position.y;
          if (ranges.some(r => y >= r.yMin && y <= r.yMax)) {
            b.mesh.visible = false;
          }
        });
      }
      hideTopTwoLayersDecorations();

      // å¢å¼ºåº•éƒ¨ä¸¤å±‚è£…é¥°ï¼šæ›´äº®ã€æ›´å¯†ä¸€ç‚¹
      function boostBottomTwoLayersBright(layerIndices = []) {
        const extraBulbColors = [0xff5a5a, 0x5ac8ff, 0x5aff94, 0xffd34f, 0xb388ff, 0xffffff];
        const rangesBottom = layerIndices.map(idx => computeLayerRange(idx)).filter(Boolean);
        // æå‡ç°æœ‰åº•éƒ¨ä¸¤å±‚å½©ç¯çš„äº®åº¦åŸºå‡†
        bulbs.forEach(b => {
          const y = b.mesh.position.y;
          if (rangesBottom.some(r => y >= r.yMin && y <= r.yMax)) {
            b.baseIntensity = Math.max(b.baseIntensity || 0.8, 0.9);
            if (b.mesh.material && 'emissiveIntensity' in b.mesh.material) {
              b.mesh.material.emissiveIntensity = Math.max(b.mesh.material.emissiveIntensity || 0.9, 1.08);
            }
          }
        });
        // è¿›ä¸€æ­¥åœ¨åº•éƒ¨ä¸¤å±‚å¢åŠ æ›´äº®çš„å½©ç¯ã€ç¤¼ç‰©ã€èŠ±æœµä¸æ°´æœ
        layerIndices.forEach(idx => {
          const { mesh, radius, height } = foliageCones[idx] || {};
          if (!mesh) return;

          // å½©ç¯ï¼ˆæ›´äº®ï¼‰
          const countBulb = 22;
          for (let i=0; i<countBulb; i++) {
            const t = Math.random();
            const yLocal = (t * 0.9 + 0.05) * height - height / 2 + (Math.random() - 0.5) * 0.2;
            const ang = Math.random()*Math.PI*2;
            const localRadius = radius * (1 - (yLocal + height / 2) / height * 0.86);
            const x = Math.cos(ang) * localRadius; const z = Math.sin(ang) * localRadius;
            const bulbGeo = new THREE.SphereGeometry(0.22 + Math.random()*0.08, 12, 12);
            const color = extraBulbColors[i % extraBulbColors.length];
            const bulbMat = new THREE.MeshPhysicalMaterial({ color, emissive: color, emissiveIntensity: 1.15, roughness: 0.25, metalness: 0.7 });
            const bulb = new THREE.Mesh(bulbGeo, bulbMat);
            bulb.position.set(mesh.position.x + x, mesh.position.y + yLocal, mesh.position.z + z);
            bulb.castShadow = false; treeGroup.add(bulb);
            bulbs.push({ mesh: bulb, baseIntensity: 0.9 + Math.random()*0.2, phase: Math.random()*Math.PI*2 });
          }

          // ç¤¼ç‰©ï¼ˆæ›´äº®çš„ä¸å¸¦ï¼‰
          const countGift = 10; const countFlower = 22; const countFruit = 18;
          for (let i=0; i<countGift; i++) {
            const color = giftColors[Math.floor(Math.random()*giftColors.length)];
            const gSize = 0.30 + Math.random()*0.12;
            const box = new THREE.Mesh(new THREE.BoxGeometry(gSize, gSize, gSize), new THREE.MeshPhysicalMaterial({ color, roughness: 0.5, metalness: 0.2 }));
            const t = Math.random(); const yLocal = (t * 0.9 + 0.05) * height - height / 2 + (Math.random() - 0.5) * 0.2; const ang = Math.random()*Math.PI*2;
            const localRadius = radius * (1 - (yLocal + height / 2) / height * 0.9);
            const pos = new THREE.Vector3(mesh.position.x + Math.cos(ang)*localRadius, mesh.position.y + yLocal, mesh.position.z + Math.sin(ang)*localRadius);
            box.position.copy(pos); box.castShadow = true; ornamentGroup.add(box);
            const thick = Math.max(0.02, gSize*0.085); const heightB = gSize*1.06;
      const ribbon1 = new THREE.Mesh(new THREE.BoxGeometry(thick, heightB, gSize), new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.80 }));
      const ribbon2 = new THREE.Mesh(new THREE.BoxGeometry(gSize, heightB, thick), new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.80 }));
            ribbon1.position.copy(pos); ribbon2.position.copy(pos);
            ornamentGroup.add(ribbon1); ornamentGroup.add(ribbon2);
            bulbs.push({ mesh: ribbon1, baseIntensity: 0.9 + Math.random()*0.2, phase: Math.random()*Math.PI*2 });
            bulbs.push({ mesh: ribbon2, baseIntensity: 0.9 + Math.random()*0.2, phase: Math.random()*Math.PI*2 });
          }

          // èŠ±æœµ
          for (let i=0; i<countFlower; i++) {
            const c = flowerColors[Math.floor(Math.random()*flowerColors.length)];
            const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: makeColoredFlowerTexture(c), color: 0xffffff, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending }));
            const t = Math.random(); const yLocal = (t * 0.9 + 0.05) * height - height / 2 + (Math.random() - 0.5) * 0.2; const ang = Math.random()*Math.PI*2;
            const localRadius = radius * (1 - (yLocal + height / 2) / height * 0.92) * (1 + (Math.random()-0.5)*0.12);
            spr.position.set(mesh.position.x + Math.cos(ang)*localRadius, mesh.position.y + yLocal, mesh.position.z + Math.sin(ang)*localRadius);
            spr.scale.setScalar(1.0 + Math.random()*0.6); ornamentGroup.add(spr);
          }

          // æ°´æœï¼ˆè‹¹æœ/é¦™è•‰ï¼‰
          for (let i=0; i<countFruit; i++) {
            const isBanana = Math.random() < 0.5;
            const t = Math.random(); const yLocal = (t * 0.9 + 0.05) * height - height / 2 + (Math.random() - 0.5) * 0.2; const ang = Math.random()*Math.PI*2;
            const localRadius = radius * (1 - (yLocal + height / 2) / height * 0.9) * (1 + (Math.random()-0.5)*0.12);
            const pos = new THREE.Vector3(mesh.position.x + Math.cos(ang)*localRadius, mesh.position.y + yLocal, mesh.position.z + Math.sin(ang)*localRadius);
            if (isBanana) {
              const banana = createBananaMesh(); banana.position.copy(pos);
              ornamentGroup.add(banana);
              bulbs.push({ mesh: banana, baseIntensity: 0.9 + Math.random()*0.2, phase: Math.random()*Math.PI*2 });
            } else {
              const appleMat = new THREE.MeshPhysicalMaterial({ color: 0xff4a4a, emissive: 0xff4a4a, emissiveIntensity: 0.75, roughness: 0.4, metalness: 0.3 });
              const apple = new THREE.Mesh(new THREE.SphereGeometry(0.18, 12, 12), appleMat);
              apple.position.copy(pos); apple.castShadow = true; ornamentGroup.add(apple);
              bulbs.push({ mesh: apple, baseIntensity: 0.9 + Math.random()*0.2, phase: Math.random()*Math.PI*2 });
            }
          }
        });
      }
      boostBottomTwoLayersBright(bottom2);

      // å°†é¡¶éƒ¨è´è¶çš„ä¸€åŠç§»åŠ¨åˆ°ä¸‹é¢ä¸¤å±‚
      function moveHalfTopButterfliesToBottomTwo(bottomIndices = []) {
        const n = foliageCones.length;
        const topRanges = [computeLayerRange(n-1), computeLayerRange(n-2)].filter(Boolean);
        const isInRanges = (y) => topRanges.some(r => y >= r.yMin && y <= r.yMax);
        const topButterflies = butterflies.filter(b => {
          if (b.mode === 'perch') return isInRanges(b.group.position.y);
          if (b.mode === 'around') return isInRanges(b.baseY ?? b.group.position.y);
          return false;
        });
        const moveCount = Math.floor(topButterflies.length * 0.5);
        // æ‰“ä¹±é€‰æ‹©ï¼Œé¿å…æ€»æ˜¯åŒä¸€æ‰¹
        for (let i = topButterflies.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [topButterflies[i], topButterflies[j]] = [topButterflies[j], topButterflies[i]];
        }
        const selected = topButterflies.slice(0, moveCount);
        selected.forEach(b => {
          const destIdx = bottomIndices[Math.floor(Math.random() * bottomIndices.length)];
          const layer = foliageCones[destIdx]; if (!layer) return;
          const { mesh, radius, height } = layer;
          if (b.mode === 'perch') {
            const t = Math.random();
            const yLocal = (t * 0.9 + 0.05) * height - height / 2 + (Math.random() - 0.5) * 0.22;
            const ang = Math.random() * Math.PI * 2;
            const r = radius * (1 - (yLocal + height/2) / height * 0.92) * (1 + (Math.random() - 0.5) * 0.12);
            const pos = new THREE.Vector3(mesh.position.x + Math.cos(ang)*r, mesh.position.y + yLocal, mesh.position.z + Math.sin(ang)*r);
            b.group.position.copy(pos);
            b.group.rotation.y = ang + Math.PI/2;
          } else if (b.mode === 'around') {
            const angle = Math.random() * Math.PI * 2;
            const baseY = mesh.position.y + (Math.random() - 0.5) * 0.4;
            const rFly = radius * (1.1 + Math.random() * 0.25);
            b.angle = angle; b.baseY = baseY; b.radius = rFly;
            b.group.position.set(Math.cos(angle) * rFly, baseY, Math.sin(angle) * rFly);
            b.group.rotation.y = -angle + Math.PI/2;
          }
        });
      }
      moveHalfTopButterfliesToBottomTwo(bottom2);
      // è°ƒæ•´åœé©»è´è¶çš„è§’åº¦åˆ†å¸ƒï¼Œä½¿å„å±‚è¦†ç›–æ›´å‡åŒ€ï¼ˆä¿ç•™è½»å¾®æ‰°åŠ¨ç»´æŒé”™è½æ„Ÿï¼‰
      rebalancePerchedButterfliesEvenly({ angleNoise: 0.18, radiusNoise: 0.06 });
      // åˆæ¬¡æ‘„åƒæœºé€‚é…ï¼Œä¿è¯æ•´æ£µæ ‘ä¸åº•ç›˜éƒ½åœ¨å¯è§†èŒƒå›´å†…
      fitCameraToTreeGroup({ margin: 1.16 });

      // â€”â€” ä¸ºæ‰€æœ‰æ ‘å±‚è¡¥å……ä¸€åœˆâ€œå°ç¤¼ç‰©å¸¦â€ï¼Œå‡åŒ€è§’åº¦åˆ†å¸ƒ + è½»å¾®æ‰°åŠ¨ï¼Œé¿å…ç©ºè§’è½
      function addEvenGiftBandsOnLayers({ countScale = 1.0 } = {}) {
        const golden = Math.PI * (3 - Math.sqrt(5));
        foliageCones.forEach(({ mesh, radius, height }, layerIdx) => {
          // æ ¹æ®å±‚åŠå¾„ä¼°ç®—éœ€è¦çš„ç¤¼ç‰©æ•°é‡ï¼Œé¡¶å±‚å°‘ã€åº•å±‚ç¨å¤š
          const baseCount = Math.max(6, Math.round(radius * 3));
          const N = Math.round(baseCount * countScale);
          for (let i=0;i<N;i++) {
            const ang = (i * golden) % (Math.PI * 2) + (Math.random()-0.5) * 0.16;
            const t = (i + 0.5) / N; // åˆ†å±‚é«˜åº¦å‡åŒ€å–æ ·
            const yLocal = (t * 0.8 + 0.1) * height - height / 2 + (Math.random()-0.5) * 0.08;
            const baseR = radius * (1 - (yLocal + height / 2) / height * 0.9);
            const localR = baseR * (1 + (Math.random()-0.5) * 0.08);
            const pos = new THREE.Vector3(mesh.position.x + Math.cos(ang)*localR, mesh.position.y + yLocal, mesh.position.z + Math.sin(ang)*localR);
            const color = giftColors[Math.floor(Math.random()*giftColors.length)];
            const gSize = 0.18 + Math.random()*0.08; // å°å°ºå¯¸ï¼Œé¿å…æ‹¥æŒ¤
            const box = new THREE.Mesh(new THREE.BoxGeometry(gSize, gSize, gSize), new THREE.MeshPhysicalMaterial({ color, emissive: mixHexColor(color, 0xffffff, 0.72), emissiveIntensity: 0.28, roughness: 0.5, metalness: 0.25 }));
            box.position.copy(pos); box.castShadow = true; ornamentGroup.add(box);
            const haloCol = mixHexColor(color, 0xffffff, 0.86);
            const halo = new THREE.Sprite(new THREE.SpriteMaterial({ map: makeHaloTexture('#ffffff'), color: haloCol, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending }));
            halo.scale.setScalar(0.2 + Math.random()*0.12);
            halo.position.copy(pos.clone().add(new THREE.Vector3(0, 0.02, 0)));
            ornamentGroup.add(halo);
            const thick = Math.max(0.014, gSize*0.085); const heightB = gSize*1.06;
      const ribbon1 = new THREE.Mesh(new THREE.BoxGeometry(thick, heightB, gSize), new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.76 }));
      const ribbon2 = new THREE.Mesh(new THREE.BoxGeometry(gSize, heightB, thick), new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.76 }));
            ribbon1.position.copy(pos); ribbon2.position.copy(pos);
            ornamentGroup.add(ribbon1); ornamentGroup.add(ribbon2);
            bulbs.push({ mesh: ribbon1, baseIntensity: 0.82 + Math.random()*0.22, phase: Math.random()*Math.PI*2 });
            bulbs.push({ mesh: ribbon2, baseIntensity: 0.82 + Math.random()*0.22, phase: Math.random()*Math.PI*2 });
          }
        });
      }
      addEvenGiftBandsOnLayers({ countScale: 0.85 });

      // åœ¨é¡¶éƒ¨å¢åŠ ä¸€åœˆå½©ç¯ã€èŠ±èŠ±ã€å¶å­ã€æœå­è£…é¥°
      function addTopRingDecorations() {
        const topIdx = foliageCones.length - 1;
        const { mesh, radius, height } = foliageCones[topIdx] || {};
        if (!mesh) return;
        const ringY = mesh.position.y + height * 0.36; // é è¿‘æœ€é¡¶ç«¯ä½†ç¨å¾®ä¸‹ç§»ï¼Œé¿å…æŒ¤åˆ°æ˜Ÿæ˜Ÿ
        const ringR = radius * 0.78;
        const extraBulbColors = [0xff5a5a, 0x5ac8ff, 0x5aff94, 0xffd34f, 0xb388ff, 0xffffff];

        // å½©ç¯ä¸€åœˆ
        const bulbCount = 22;
        for (let i=0;i<bulbCount;i++) {
          const ang = (i / bulbCount) * Math.PI * 2 + Math.random()*0.1;
          const x = Math.cos(ang) * ringR; const z = Math.sin(ang) * ringR;
          const bulbGeo = new THREE.SphereGeometry(0.18 + Math.random()*0.08, 12, 12);
          const color = extraBulbColors[i % extraBulbColors.length];
          const bulbMat = new THREE.MeshPhysicalMaterial({ color, emissive: color, emissiveIntensity: 1.08, roughness: 0.25, metalness: 0.7 });
          const bulb = new THREE.Mesh(bulbGeo, bulbMat);
          bulb.position.set(mesh.position.x + x, ringY, mesh.position.z + z);
          bulb.castShadow = false; treeGroup.add(bulb);
          bulbs.push({ mesh: bulb, baseIntensity: 0.88 + Math.random()*0.22, phase: Math.random()*Math.PI*2 });
        }

        // èŠ±æœµä¸€åœˆ
        const flowerCount = 16;
        for (let i=0;i<flowerCount;i++) {
          const ang = (i / flowerCount) * Math.PI * 2 + Math.random()*0.12;
          const rJitter = ringR * (1 + (Math.random()-0.5)*0.06);
          const x = Math.cos(ang) * rJitter; const z = Math.sin(ang) * rJitter;
          const c = flowerColors[Math.floor(Math.random()*flowerColors.length)];
          const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: makeColoredFlowerTexture(c), color: 0xffffff, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending }));
          spr.position.set(mesh.position.x + x, ringY + (Math.random()-0.5)*0.12, mesh.position.z + z);
          spr.scale.setScalar(1.0 + Math.random()*0.5); ornamentGroup.add(spr);
        }

        // å¶å­ä¸€åœˆ
        const leafCount = 20;
        for (let i=0;i<leafCount;i++) {
          const ang = (i / leafCount) * Math.PI * 2 + Math.random()*0.14;
          const rJ = ringR * (1 + (Math.random()-0.5)*0.06);
          const x = Math.cos(ang) * rJ; const z = Math.sin(ang) * rJ;
          const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: makeLeafTexture(), color: leafColors[i % leafColors.length], transparent: true, depthWrite: false, blending: THREE.AdditiveBlending }));
          spr.position.set(mesh.position.x + x, ringY + (Math.random()-0.5)*0.12, mesh.position.z + z);
          spr.scale.setScalar(0.9 + Math.random()*0.5); ornamentGroup.add(spr);
        }

        // æœå­ä¸€åœˆï¼ˆè‹¹æœ/é¦™è•‰æ··åˆï¼‰
        const fruitCount = 14;
        for (let i=0;i<fruitCount;i++) {
          const ang = (i / fruitCount) * Math.PI * 2 + Math.random()*0.12;
          const rJ = ringR * (1 + (Math.random()-0.5)*0.05);
          const x = Math.cos(ang) * rJ; const z = Math.sin(ang) * rJ;
          const pos = new THREE.Vector3(mesh.position.x + x, ringY + (Math.random()-0.5)*0.1, mesh.position.z + z);
          const isBanana = Math.random() < 0.5;
          if (isBanana) {
            const banana = createBananaMesh(); banana.position.copy(pos);
            ornamentGroup.add(banana);
            bulbs.push({ mesh: banana, baseIntensity: 0.85 + Math.random()*0.22, phase: Math.random()*Math.PI*2 });
          } else {
            const appleMat = new THREE.MeshPhysicalMaterial({ color: 0xff4a4a, emissive: 0xff4a4a, emissiveIntensity: 0.72, roughness: 0.4, metalness: 0.3 });
            const apple = new THREE.Mesh(new THREE.SphereGeometry(0.18, 12, 12), appleMat);
            apple.position.copy(pos); apple.castShadow = true; ornamentGroup.add(apple);
            bulbs.push({ mesh: apple, baseIntensity: 0.86 + Math.random()*0.2, phase: Math.random()*Math.PI*2 });
          }
        }
      }
      addTopRingDecorations();

      // é¡¶éƒ¨ç¬¬äºŒå±‚ä¹Ÿå¢åŠ ä¸€åœˆå½©ç¯ã€èŠ±èŠ±ã€å¶å­ã€æœå­
      function addSecondTopRingDecorations() {
        const topIdx2 = foliageCones.length - 2;
        const { mesh, radius, height } = foliageCones[topIdx2] || {};
        if (!mesh) return;
        const ringY = mesh.position.y + height * 0.18; // ä½äºç¬¬äºŒå±‚çš„ä¸ŠåŠéƒ¨
        const ringR = radius * 0.82;
        const extraBulbColors = [0xff5a5a, 0x5ac8ff, 0x5aff94, 0xffd34f, 0xb388ff, 0xffffff];

        // å½©ç¯ä¸€åœˆï¼ˆæ•°é‡ç¨å¤šäºé¡¶éƒ¨ï¼‰
        const bulbCount = 26;
        for (let i=0;i<bulbCount;i++) {
          const ang = (i / bulbCount) * Math.PI * 2 + Math.random()*0.1;
          const x = Math.cos(ang) * ringR; const z = Math.sin(ang) * ringR;
          const bulbGeo = new THREE.SphereGeometry(0.18 + Math.random()*0.08, 12, 12);
          const color = extraBulbColors[i % extraBulbColors.length];
          const bulbMat = new THREE.MeshPhysicalMaterial({ color, emissive: color, emissiveIntensity: 1.08, roughness: 0.25, metalness: 0.7 });
          const bulb = new THREE.Mesh(bulbGeo, bulbMat);
          bulb.position.set(mesh.position.x + x, ringY, mesh.position.z + z);
          bulb.castShadow = false; treeGroup.add(bulb);
          bulbs.push({ mesh: bulb, baseIntensity: 0.88 + Math.random()*0.22, phase: Math.random()*Math.PI*2 });
        }

        // èŠ±æœµä¸€åœˆ
        const flowerCount = 18;
        for (let i=0;i<flowerCount;i++) {
          const ang = (i / flowerCount) * Math.PI * 2 + Math.random()*0.12;
          const rJitter = ringR * (1 + (Math.random()-0.5)*0.06);
          const x = Math.cos(ang) * rJitter; const z = Math.sin(ang) * rJitter;
          const c = flowerColors[Math.floor(Math.random()*flowerColors.length)];
          const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: makeColoredFlowerTexture(c), color: 0xffffff, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending }));
          spr.position.set(mesh.position.x + x, ringY + (Math.random()-0.5)*0.12, mesh.position.z + z);
          spr.scale.setScalar(1.0 + Math.random()*0.5); ornamentGroup.add(spr);
        }

        // å¶å­ä¸€åœˆ
        const leafCount = 24;
        for (let i=0;i<leafCount;i++) {
          const ang = (i / leafCount) * Math.PI * 2 + Math.random()*0.14;
          const rJ = ringR * (1 + (Math.random()-0.5)*0.06);
          const x = Math.cos(ang) * rJ; const z = Math.sin(ang) * rJ;
          const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: makeLeafTexture(), color: leafColors[i % leafColors.length], transparent: true, depthWrite: false, blending: THREE.AdditiveBlending }));
          spr.position.set(mesh.position.x + x, ringY + (Math.random()-0.5)*0.12, mesh.position.z + z);
          spr.scale.setScalar(0.9 + Math.random()*0.5); ornamentGroup.add(spr);
        }

        // æœå­ä¸€åœˆï¼ˆè‹¹æœ/é¦™è•‰æ··åˆï¼‰
        const fruitCount = 16;
        for (let i=0;i<fruitCount;i++) {
          const ang = (i / fruitCount) * Math.PI * 2 + Math.random()*0.12;
          const rJ = ringR * (1 + (Math.random()-0.5)*0.05);
          const x = Math.cos(ang) * rJ; const z = Math.sin(ang) * rJ;
          const pos = new THREE.Vector3(mesh.position.x + x, ringY + (Math.random()-0.5)*0.1, mesh.position.z + z);
          const isBanana = Math.random() < 0.5;
          if (isBanana) {
            const banana = createBananaMesh(); banana.position.copy(pos);
            ornamentGroup.add(banana);
            bulbs.push({ mesh: banana, baseIntensity: 0.85 + Math.random()*0.22, phase: Math.random()*Math.PI*2 });
          } else {
            const appleMat = new THREE.MeshPhysicalMaterial({ color: 0xff4a4a, emissive: 0xff4a4a, emissiveIntensity: 0.72, roughness: 0.4, metalness: 0.3 });
            const apple = new THREE.Mesh(new THREE.SphereGeometry(0.18, 12, 12), appleMat);
            apple.position.copy(pos); apple.castShadow = true; ornamentGroup.add(apple);
            bulbs.push({ mesh: apple, baseIntensity: 0.86 + Math.random()*0.2, phase: Math.random()*Math.PI*2 });
          }
        }
      }
      addSecondTopRingDecorations();

      // é¡¶éƒ¨å‡å°‘åŸæ¥ 2/9 çš„è£…é¥°ï¼ˆéšæœºéšè—è¯¥èŒƒå›´å†…çš„éƒ¨åˆ† ornament ä¸ bulbsï¼‰
      function reduceTopLayerDecorationsByFraction(frac = 2/9) {
        const n = foliageCones.length; const range = computeLayerRange(n-1); if (!range) return;
        const ornamentsTop = ornamentGroup.children.filter(obj => obj.visible !== false && obj.position.y >= range.yMin && obj.position.y <= range.yMax);
        const bulbsTop = bulbs.filter(b => b.mesh.visible !== false && b.mesh.position.y >= range.yMin && b.mesh.position.y <= range.yMax);
        const hideCountOrn = Math.floor(ornamentsTop.length * frac);
        const hideCountBulb = Math.floor(bulbsTop.length * frac);
        // æ‰“ä¹±åéšè—
        for (let i = ornamentsTop.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [ornamentsTop[i], ornamentsTop[j]] = [ornamentsTop[j], ornamentsTop[i]]; }
        for (let i = bulbsTop.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [bulbsTop[i], bulbsTop[j]] = [bulbsTop[j], bulbsTop[i]]; }
        ornamentsTop.slice(0, hideCountOrn).forEach(obj => { obj.visible = false; });
        bulbsTop.slice(0, hideCountBulb).forEach(b => { b.mesh.visible = false; });
      }
      reduceTopLayerDecorationsByFraction(2/9);

      // é€šç”¨ï¼šåœ¨æŒ‡å®šé«˜åº¦ä¸åŠå¾„å¤„å¢åŠ ä¸€åœˆå½©ç¯ã€èŠ±æœµã€å¶å­ã€æœå­
      function addRingDecorationsAt(ringY, ringR, opts = {}) {
        const bulbCount = opts.bulbCount ?? 24;
        const flowerCount = opts.flowerCount ?? 18;
        const leafCount = opts.leafCount ?? 22;
        const fruitCount = opts.fruitCount ?? 14;
        const extraBulbColors = [0xff5a5a, 0x5ac8ff, 0x5aff94, 0xffd34f, 0xb388ff, 0xffffff];

        // å½©ç¯ä¸€åœˆ
        for (let i=0;i<bulbCount;i++) {
          const ang = (i / bulbCount) * Math.PI * 2 + Math.random()*0.1;
          const x = Math.cos(ang) * ringR; const z = Math.sin(ang) * ringR;
          const bulbGeo = new THREE.SphereGeometry(0.18 + Math.random()*0.08, 12, 12);
          const color = extraBulbColors[i % extraBulbColors.length];
          const bulbMat = new THREE.MeshPhysicalMaterial({ color, emissive: color, emissiveIntensity: 1.08, roughness: 0.25, metalness: 0.7 });
          const bulb = new THREE.Mesh(bulbGeo, bulbMat);
          bulb.position.set(x, ringY, z);
          // æ³¨æ„ï¼šringåæ ‡ä¸ºæ ‘å±€éƒ¨åæ ‡ï¼Œéœ€åŠ  treeGroup å˜æ¢ã€‚æˆ‘ä»¬å°†å…¶æ·»åŠ åˆ° treeGroup å±€éƒ¨å¹¶ä¿æŒåæ ‡åŸç‚¹ä¸ºæ ‘çš„ä¸­å¿ƒã€‚
          treeGroup.add(bulb);
          bulbs.push({ mesh: bulb, baseIntensity: 0.88 + Math.random()*0.22, phase: Math.random()*Math.PI*2 });
        }

        // èŠ±æœµä¸€åœˆ
        for (let i=0;i<flowerCount;i++) {
          const ang = (i / flowerCount) * Math.PI * 2 + Math.random()*0.12;
          const rJitter = ringR * (1 + (Math.random()-0.5)*0.06);
          const x = Math.cos(ang) * rJitter; const z = Math.sin(ang) * rJitter;
          const c = flowerColors[Math.floor(Math.random()*flowerColors.length)];
          const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: makeColoredFlowerTexture(c), color: 0xffffff, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending }));
          spr.position.set(x, ringY + (Math.random()-0.5)*0.12, z);
          spr.scale.setScalar(1.0 + Math.random()*0.5); ornamentGroup.add(spr);
        }

        // å¶å­ä¸€åœˆ
        for (let i=0;i<leafCount;i++) {
          const ang = (i / leafCount) * Math.PI * 2 + Math.random()*0.14;
          const rJ = ringR * (1 + (Math.random()-0.5)*0.06);
          const x = Math.cos(ang) * rJ; const z = Math.sin(ang) * rJ;
          const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: makeLeafTexture(), color: leafColors[i % leafColors.length], transparent: true, depthWrite: false, blending: THREE.AdditiveBlending }));
          spr.position.set(x, ringY + (Math.random()-0.5)*0.12, z);
          spr.scale.setScalar(0.9 + Math.random()*0.5); ornamentGroup.add(spr);
        }

        // æœå­ä¸€åœˆï¼ˆè‹¹æœ/é¦™è•‰æ··åˆï¼‰
        for (let i=0;i<fruitCount;i++) {
          const ang = (i / fruitCount) * Math.PI * 2 + Math.random()*0.12;
          const rJ = ringR * (1 + (Math.random()-0.5)*0.05);
          const x = Math.cos(ang) * rJ; const z = Math.sin(ang) * rJ;
          const pos = new THREE.Vector3(x, ringY + (Math.random()-0.5)*0.1, z);
          const isBanana = Math.random() < 0.5;
          if (isBanana) {
            const banana = createBananaMesh(); banana.position.copy(pos);
            ornamentGroup.add(banana);
            bulbs.push({ mesh: banana, baseIntensity: 0.85 + Math.random()*0.22, phase: Math.random()*Math.PI*2 });
          } else {
            const appleMat = new THREE.MeshPhysicalMaterial({ color: 0xff4a4a, emissive: 0xff4a4a, emissiveIntensity: 0.72, roughness: 0.4, metalness: 0.3 });
            const apple = new THREE.Mesh(new THREE.SphereGeometry(0.18, 12, 12), appleMat);
            apple.position.copy(pos); apple.castShadow = true; ornamentGroup.add(apple);
            bulbs.push({ mesh: apple, baseIntensity: 0.86 + Math.random()*0.2, phase: Math.random()*Math.PI*2 });
          }
        }
      }

      // åœ¨ä¸¤å±‚ä¹‹é—´åŠ å…¥ä¸€åœˆï¼šæ ¹æ®ä¸¤å±‚çš„ä¸Šä¸‹è¾¹ç•Œæ’å€¼é«˜åº¦ï¼ŒåŠå¾„é‡‡ç”¨æ ‘åœ¨è¯¥é«˜åº¦çš„ä¼°ç®—åŠå¾„
      function addRingBetweenLayers(idxLower, idxUpper, opts = {}) {
        const lower = foliageCones[idxLower]; const upper = foliageCones[idxUpper];
        if (!lower || !upper) return;
        const lowerTop = lower.mesh.position.y + lower.height / 2;
        const upperBottom = upper.mesh.position.y - upper.height / 2;
        // è‹¥å±‚é—´è·å¾ˆå°ï¼Œç•¥å¾®å‘ä¸‹åç§»ï¼Œé¿å…ä¸å±‚è¡¨é¢è£…é¥°é‡åˆ
        const ringY = (lowerTop + upperBottom) / 2 + ((upperBottom - lowerTop) < 0.3 ? -0.06 : 0);
        const ringR = treeRadiusAtY(ringY) * 0.9;
        addRingDecorationsAt(ringY, ringR, opts);
      }

      // åœ¨æŸå±‚ä¸ŠåŠ å…¥ä¸€åœˆï¼Œé»˜è®¤é è¿‘è¯¥å±‚ä¸ŠåŠéƒ¨
      function addRingOnLayer(idxLayer, opts = {}) {
        const layer = foliageCones[idxLayer]; if (!layer) return;
        const ringY = layer.mesh.position.y + layer.height * 0.22;
        const ringR = layer.radius * 0.86;
        addRingDecorationsAt(ringY, ringR, opts);
      }

      // æŒ‰ç”¨æˆ·è¦æ±‚ï¼š
      // - ç¬¬ä¸€å±‚ä¸ç¬¬äºŒå±‚ä¹‹é—´å¢åŠ ä¸€åœˆ
      // - ç¬¬äºŒå±‚ä¸ç¬¬ä¸‰å±‚ä¹‹é—´å¢åŠ ä¸€åœˆ
      // - æœ€ä½å±‚ä¸å€’æ•°ç¬¬äºŒå±‚ä¹‹é—´ä¹Ÿå¢åŠ ä¸€åœˆ
      // - æœ€ä½å±‚æœ¬èº«ä¹Ÿå¢åŠ ä¸€åœˆ
      const idx0 = 0, idx1 = 1, idx2 = 2; // ä»ä¸‹å¾€ä¸Š
      addRingBetweenLayers(idx0, idx1, { bulbCount: 24, flowerCount: 18, leafCount: 22, fruitCount: 14 });
      addRingBetweenLayers(idx1, idx2, { bulbCount: 24, flowerCount: 18, leafCount: 22, fruitCount: 14 });
      addRingBetweenLayers(idx0, idx1, { bulbCount: 20, flowerCount: 16, leafCount: 20, fruitCount: 12 }); // é¢å¤–ä¸€åœˆï¼ŒåŠ å¼ºåº•éƒ¨å±‚é—´
      addRingOnLayer(idx0, { bulbCount: 22, flowerCount: 16, leafCount: 20, fruitCount: 12 });

      // é™¤äº†é¡¶éƒ¨ä¸Šä¸‰å±‚ä¸å˜ï¼Œå…¶ä½™å±‚äº®åº¦è½»å¾®æå‡
      function brightenLowerLayersExceptTop3() {
        const n = foliageCones.length;
        const topRanges = [computeLayerRange(n-1), computeLayerRange(n-2), computeLayerRange(n-3)].filter(Boolean);
        const isTop3 = (y) => topRanges.some(r => y >= r.yMin && y <= r.yMax);
        // æå‡ bulbs çš„äº®åº¦åŸºå‡†ä¸ emissiveIntensityï¼ˆå°å¹…ï¼‰
        bulbs.forEach(b => {
          const y = b.mesh.position.y;
          if (!isTop3(y)) {
            b.baseIntensity = Math.max(b.baseIntensity || 0.8, (b.baseIntensity ?? 0.8) + 0.06);
            if (b.mesh.material && 'emissiveIntensity' in b.mesh.material) {
              b.mesh.material.emissiveIntensity = Math.min((b.mesh.material.emissiveIntensity ?? 1.0) + 0.06, 1.25);
            }
          }
        });
      }
      brightenLowerLayersExceptTop3();

      // ç¬¬ä¸‰å±‚å’Œç¬¬å››å±‚ï¼ˆä»ä¸Šå¾€ä¸‹è®¡æ•°ï¼‰å¢åŠ ä¸€åœˆè£…é¥°
      function addRingsOnTop3and4() {
        const n = foliageCones.length;
        const idxTop3 = n - 3; const idxTop4 = n - 4;
        if (idxTop3 >= 0) addRingOnLayer(idxTop3, { bulbCount: 22, flowerCount: 16, leafCount: 20, fruitCount: 12 });
        if (idxTop4 >= 0) addRingOnLayer(idxTop4, { bulbCount: 22, flowerCount: 16, leafCount: 20, fruitCount: 12 });
      }
      addRingsOnTop3and4();

      // ç¬¬ä¸ƒå±‚åŠä»¥ä¸‹ï¼ˆä»ä¸Šå¾€ä¸‹è®¡æ•°ï¼‰ä¸æœ€åº•å±‚éƒ½å¢åŠ ä¸€åœˆè£…é¥°
      function addRingsTop7AndBelow() {
        const n = foliageCones.length; const idxTop7 = n - 7;
        const startBottom = 0; const endIdx = Math.max(idxTop7, 0);
        for (let i = startBottom; i <= endIdx; i++) {
          addRingOnLayer(i, { bulbCount: 18, flowerCount: 14, leafCount: 18, fruitCount: 10 });
        }
      }
      addRingsTop7AndBelow();

      // è®©ä¸‹éƒ¨å„å±‚çš„è£…é¥°æ›´å‡åŒ€ä¸”é”™è½ï¼šå¯¹ä½ç½®åšè½»å¾®è§’åº¦ä¸åŠå¾„æ‰°åŠ¨ï¼Œå¹¶åœ¨é«˜åº¦ä¸ŠåŠ ç»†å¾®èµ·ä¼
      function subtleStaggerLowerLayers() {
        const n = foliageCones.length;
        const topRanges = [computeLayerRange(n-1), computeLayerRange(n-2), computeLayerRange(n-3)].filter(Boolean);
        const isTop3 = (y) => topRanges.some(r => y >= r.yMin && y <= r.yMax);

        function jitterXZ(obj) {
          const x = obj.position.x, z = obj.position.z, y = obj.position.y;
          const r = Math.sqrt(x*x + z*z); if (r < 1e-6) return;
          let theta = Math.atan2(z, x);
          theta += (Math.random() - 0.5) * 0.18; // è½»å¾®è§’åº¦æ‰°åŠ¨
          let r2 = r * (1 + (Math.random() - 0.5) * 0.06); // åŠå¾„è½»å¾®æ‰°åŠ¨
          const rMax = treeRadiusAtY(y) * 0.95; r2 = Math.min(r2, rMax);
          obj.position.x = Math.cos(theta) * r2;
          obj.position.z = Math.sin(theta) * r2;
          obj.position.y = y + (Math.random() - 0.5) * 0.06; // é«˜åº¦ç»†å¾®èµ·ä¼
        }

        // å¤„ç† ornamentGroupï¼ˆèŠ±ã€å¶ã€æœã€ç¤¼ç‰©ã€ä¸å¸¦ç­‰ï¼‰
        ornamentGroup.children.forEach(obj => {
          if (!isTop3(obj.position.y)) {
            jitterXZ(obj);
          }
        });
        // å¤„ç† bulbsï¼ˆå½©ç¯çƒã€è‹¹æœã€é¦™è•‰ã€ä¸å¸¦è¢«è®¡å…¥ bulbsï¼‰
        bulbs.forEach(b => {
          const obj = b.mesh; if (!isTop3(obj.position.y)) {
            jitterXZ(obj);
          }
        });
      }
      subtleStaggerLowerLayers();

      // æ ‘å¹²ä¸Šé¢çš„é‚£ä¸€å±‚ï¼ˆæœ€åº•å±‚ï¼‰è¿½åŠ å°‘é‡ï¼šå½©ç¯ã€èŠ±èŠ±ã€å¶å­ã€æœå­
      function addSparseOrnamentsOnLayer(idxLayer, { bulbCount = 12, flowerCount = 10, leafCount = 12, fruitCount = 8 } = {}) {
        const layer = foliageCones[idxLayer]; if (!layer) return;
        const { mesh, radius, height } = layer;
        const extraBulbColors = [0xff5a5a, 0x5ac8ff, 0x5aff94, 0xffd34f, 0xb388ff, 0xffffff];

        // å½©ç¯ï¼ˆå°‘é‡ï¼‰
        for (let i=0;i<bulbCount;i++) {
          const t = Math.random();
          const yLocal = (t * 0.9 + 0.05) * height - height / 2 + (Math.random() - 0.5) * 0.18;
          const ang = Math.random()*Math.PI*2;
          const localRadius = radius * (1 - (yLocal + height / 2) / height * 0.88) * (1 + (Math.random()-0.5)*0.1);
          const x = Math.cos(ang) * localRadius; const z = Math.sin(ang) * localRadius;
          const bulbGeo = new THREE.SphereGeometry(0.18 + Math.random()*0.06, 12, 12);
          const color = extraBulbColors[i % extraBulbColors.length];
          const bulbMat = new THREE.MeshPhysicalMaterial({ color, emissive: color, emissiveIntensity: 1.05, roughness: 0.28, metalness: 0.65 });
          const bulb = new THREE.Mesh(bulbGeo, bulbMat);
          bulb.position.set(mesh.position.x + x, mesh.position.y + yLocal, mesh.position.z + z);
          bulb.castShadow = false; treeGroup.add(bulb);
          bulbs.push({ mesh: bulb, baseIntensity: 0.85 + Math.random()*0.2, phase: Math.random()*Math.PI*2 });
        }

        // èŠ±æœµï¼ˆå°‘é‡ï¼‰
        for (let i=0;i<flowerCount;i++) {
          const c = flowerColors[Math.floor(Math.random()*flowerColors.length)];
          const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: makeColoredFlowerTexture(c), color: 0xffffff, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending }));
          const t = Math.random(); const yLocal = (t * 0.9 + 0.05) * height - height / 2 + (Math.random() - 0.5) * 0.18; const ang = Math.random()*Math.PI*2;
          const localRadius = radius * (1 - (yLocal + height / 2) / height * 0.92) * (1 + (Math.random()-0.5)*0.12);
          spr.position.set(mesh.position.x + Math.cos(ang)*localRadius, mesh.position.y + yLocal, mesh.position.z + Math.sin(ang)*localRadius);
          spr.scale.setScalar(0.9 + Math.random()*0.4); ornamentGroup.add(spr);
        }

        // å¶å­ï¼ˆå°‘é‡ï¼‰
        for (let i=0;i<leafCount;i++) {
          const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: makeLeafTexture(), color: leafColors[i % leafColors.length], transparent: true, depthWrite: false, blending: THREE.AdditiveBlending }));
          const t = Math.random(); const yLocal = (t * 0.9 + 0.05) * height - height / 2 + (Math.random() - 0.5) * 0.18; const ang = Math.random()*Math.PI*2;
          const localRadius = radius * (1 - (yLocal + height / 2) / height * 0.92) * (1 + (Math.random()-0.5)*0.12);
          spr.position.set(mesh.position.x + Math.cos(ang)*localRadius, mesh.position.y + yLocal, mesh.position.z + Math.sin(ang)*localRadius);
          spr.scale.setScalar(0.8 + Math.random()*0.4); ornamentGroup.add(spr);
        }

        // æœå­ï¼ˆå°‘é‡ï¼Œè‹¹æœ/é¦™è•‰æ··åˆï¼‰
        for (let i=0;i<fruitCount;i++) {
          const isBanana = Math.random() < 0.5;
          const t = Math.random(); const yLocal = (t * 0.9 + 0.05) * height - height / 2 + (Math.random() - 0.5) * 0.18; const ang = Math.random()*Math.PI*2;
          const localRadius = radius * (1 - (yLocal + height / 2) / height * 0.9) * (1 + (Math.random()-0.5)*0.12);
          const pos = new THREE.Vector3(mesh.position.x + Math.cos(ang)*localRadius, mesh.position.y + yLocal, mesh.position.z + Math.sin(ang)*localRadius);
          if (isBanana) {
            const banana = createBananaMesh(); banana.position.copy(pos);
            ornamentGroup.add(banana);
            bulbs.push({ mesh: banana, baseIntensity: 0.86 + Math.random()*0.2, phase: Math.random()*Math.PI*2 });
          } else {
            const appleMat = new THREE.MeshPhysicalMaterial({ color: 0xff4a4a, emissive: 0xff4a4a, emissiveIntensity: 0.72, roughness: 0.4, metalness: 0.3 });
            const apple = new THREE.Mesh(new THREE.SphereGeometry(0.18, 12, 12), appleMat);
            apple.position.copy(pos); apple.castShadow = true; ornamentGroup.add(apple);
            bulbs.push({ mesh: apple, baseIntensity: 0.86 + Math.random()*0.2, phase: Math.random()*Math.PI*2 });
          }
        }
      }
      addSparseOrnamentsOnLayer(0, { bulbCount: 12, flowerCount: 10, leafCount: 12, fruitCount: 8 });

      // åœ¨æœ€åº•å±‚æ ‘è¾¹ç¼˜æ·»åŠ â€œæ‚¬æŒ‚â€çš„å°é“ƒé“›ä¸è´è¶ç»“æŒ‚é¥°
      function addBottomEdgeHangings({ count = 24 } = {}) {
        const layer = foliageCones[0]; if (!layer) return;
        const { mesh, radius, height } = layer;
        const attachY = mesh.position.y - height / 2 + 0.06; // è´´è¿‘åº•å±‚è¾¹ç¼˜ç•¥å‘ä¸Šï¼Œæ¨¡æ‹ŸæŒ‚åœ¨è¾¹ç¼˜
        const ringR = radius * 0.98; // è´´è¿‘å¤–æ²¿
        const colors = [0xffd34f, 0xff8fc7, 0x53b6ff, 0x5aff94, 0xffffff, 0xb388ff];
        for (let i = 0; i < count; i++) {
          const ang = (i / count) * Math.PI * 2 + (Math.random()-0.5)*0.12;
          const x = Math.cos(ang) * ringR;
          const z = Math.sin(ang) * ringR;
          const group = new THREE.Group();
          group.position.set(x, attachY, z);
          group._swayPhase = Math.random() * Math.PI * 2;
          group._swayAmp = 0.08 + Math.random() * 0.06; // è½»å¾®æ‘†åŠ¨å¹…åº¦
          // æ”¾å¤§åˆ°åŸæ¥å°ºå¯¸çš„ä¸¤å€
          group.scale.set(2.0, 2.0, 2.0);

          // ç»†çº¿ï¼ˆæŒ‚ç»³ï¼‰
          const lineLen = 0.18 + Math.random()*0.06;
          const lineGeo = new THREE.CylinderGeometry(0.01, 0.01, lineLen, 8);
          const lineMat = new THREE.MeshStandardMaterial({ color: 0xdddddd, metalness: 0.6, roughness: 0.35 });
          const line = new THREE.Mesh(lineGeo, lineMat);
          line.position.y = -lineLen / 2; group.add(line);

          const isBell = Math.random() < 0.55; // 55% é“ƒé“›ï¼Œ45% è´è¶ç»“
          const color = colors[i % colors.length];
          if (isBell) {
            // é“ƒé“›ä¸»ä½“
            const bellMat = new THREE.MeshPhysicalMaterial({ color, emissive: mixHexColor(color, 0xffffff, 0.78), emissiveIntensity: 0.28, metalness: 0.94, roughness: 0.18 });
            const body = new THREE.Mesh(new THREE.SphereGeometry(0.075, 16, 12), bellMat);
            body.position.y = -lineLen - 0.04; group.add(body);
            // ä¸‹æ‘†ï¼ˆè£™è¾¹ï¼‰
            const skirt = new THREE.Mesh(new THREE.ConeGeometry(0.085, 0.08, 16), bellMat);
            skirt.position.y = -lineLen - 0.09; group.add(skirt);
            // é“ƒèˆŒ
            const clapper = new THREE.Mesh(new THREE.SphereGeometry(0.02, 10, 10), new THREE.MeshStandardMaterial({ color: 0x663300, metalness: 0.3, roughness: 0.6 }));
            clapper.position.y = -lineLen - 0.14; group.add(clapper);
          } else {
            // è´è¶ç»“ä¸»ä½“
            const bowMat = new THREE.MeshPhysicalMaterial({ color, emissive: mixHexColor(color, 0xffffff, 0.78), emissiveIntensity: 0.24, metalness: 0.72, roughness: 0.38 });
            const center = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.04, 0.02), bowMat);
            center.position.y = -lineLen - 0.05; group.add(center);
            const loopL = new THREE.Mesh(new THREE.TorusGeometry(0.05, 0.012, 10, 16), bowMat); loopL.position.set(-0.06, -lineLen - 0.05, 0); group.add(loopL);
            const loopR = new THREE.Mesh(new THREE.TorusGeometry(0.05, 0.012, 10, 16), bowMat); loopR.position.set(0.06, -lineLen - 0.05, 0); group.add(loopR);
            const tailL = new THREE.Mesh(new THREE.PlaneGeometry(0.12, 0.026), bowMat); tailL.position.set(-0.03, -lineLen - 0.13, 0); tailL.rotation.z = Math.PI/18; group.add(tailL);
            const tailR = new THREE.Mesh(new THREE.PlaneGeometry(0.12, 0.026), bowMat); tailR.position.set(0.03, -lineLen - 0.13, 0); tailR.rotation.z = -Math.PI/18; group.add(tailR);
          }

          // é—ªäº®å°å…‰æ–‘ï¼ˆä½¿ç”¨ç™½è‰²çº¹ç†ï¼Œå¹¶å°†å…‰æ™•é¢œè‰²è°ƒæˆâ€œæŒ‚ä»¶è‡ªèº«é¢œè‰²çš„æ·¡åŒ–ç‰ˆâ€ï¼‰
          const glow1 = mixHexColor(color, 0xffffff, 0.78); // å†æµ…ä¸€ç‚¹çš„åŒè‰²å…‰æ™•
          const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: makeHaloTexture('#ffffff'), color: glow1, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending }));
          spr.scale.setScalar(0.36 + Math.random()*0.18);
          spr.position.set((Math.random()-0.5)*0.1, -lineLen - 0.05 + (Math.random()-0.5)*0.08, (Math.random()-0.5)*0.1);
          group.add(spr);
          group._sparkle = spr;
          // é¢å¤–çš„å¾®å°é—ªå…‰ï¼Œå¢å¼ºâ€œé—ªäº®äº®â€æ•ˆæœï¼ˆæ›´æ·¡æ›´äº®çš„åŒè‰²å…‰æ™•ï¼‰
          const glow2 = mixHexColor(color, 0xffffff, 0.92);
          const spr2 = new THREE.Sprite(new THREE.SpriteMaterial({ map: makeHaloTexture('#ffffff'), color: glow2, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending }));
          spr2.scale.setScalar(0.22 + Math.random()*0.12);
          spr2.position.set((Math.random()-0.5)*0.1, -lineLen - 0.08 + (Math.random()-0.5)*0.08, (Math.random()-0.5)*0.1);
          group.add(spr2);
          group._sparkle2 = spr2;

          // è®°å½•åŸºç¡€é¢œè‰²ç”¨äºåç»­ç‚¹ç¼€
          group._baseColor = color;
          // å¤§å°äº¤æ›¿ï¼šéšæœºé€‰æ‹©â€œæ¯éš”1ä¸ªâ€æˆ–â€œæ¯éš”2ä¸ªâ€è®¾ä¸º 1.35 å€
          const useIntervalTwo = window.__hangIntervalTwo ?? (Math.random() < 0.5);
          window.__hangIntervalTwo = useIntervalTwo;
          const idx = bottomHangings.length; // å½“å‰å°†è¦æ’å…¥çš„ä½ç½®ç´¢å¼•
          const isLarge = useIntervalTwo ? (idx % 2 === 0) : (idx % 3 === 0);
          if (isLarge) group.scale.multiplyScalar(1.35);

          // åœ¨æŒ‚ç‚¹é™„è¿‘ä¸è¯¥å±‚æ ‘ä¸Šç‚¹ç¼€äº®äº®çš„å°è£…é¥°
          addAccentItemsNearAnchor(group.position.clone(), color);

          group.frustumCulled = false;
          treeGroup.add(group);
          bottomHangings.push(group);
        }
      }

      addBottomEdgeHangings({ count: 26 });

      // ç²‰è‰²æ‰‹ç»˜â€œæ¨ªå‘ç¬”è§¦â€æ ‘å† ï¼ˆå¤åˆ»ç¤ºä¾‹å›¾ç‰‡çš„é£æ ¼ï¼‰
      const scribbleGroup = new THREE.Group();
      treeGroup.add(scribbleGroup);
      const scribbleLines = [];
      function buildPinkScribbleTree() {
        // éšè—åŸæ¥çš„åœ†é”¥æ ‘å† 
        foliageCones.forEach(({ mesh }) => mesh.visible = false);

        const layers = 42; // æ¨ªå‘ç¬”è§¦æ•°é‡
        const fullW = baseRadius * 2.2; // çº¿æ¡æœ€å¤§å®½åº¦
        const baseY = trunk.position.y + 0.8; // èµ·å§‹é«˜åº¦
        const topY = star.position.y - 1.6;
        const height = topY - baseY;

        for (let i = 0; i < layers; i++) {
          const t = i / (layers - 1);
          const y = baseY + t * height;
          const width = fullW * (1 - t * 0.96) + 0.4; // ä¸Šçª„ä¸‹å®½
          const jitter = 0.12 + (1 - t) * 0.08; // éšæœºæŠ–åŠ¨å¼ºåº¦
          const points = [];
          const seg = 8 + Math.floor(Math.random() * 6);
          for (let s = 0; s <= seg; s++) {
            const nx = -width / 2 + (s / seg) * width;
            const ny = y + (Math.random() - 0.5) * jitter;
            const nz = (Math.random() - 0.5) * jitter * 0.5;
            points.push(new THREE.Vector3(nx, ny, nz));
          }
          const curve = new THREE.CatmullRomCurve3(points);
          const geo = new THREE.TubeGeometry(curve, 64, 0.08 + (1 - t) * 0.03, 16, false);
          const mat = new THREE.MeshPhysicalMaterial({
            color: 0xff86c1,
            emissive: 0xff98cf,
            emissiveIntensity: 0.25,
            roughness: 0.6,
            metalness: 0.05
          });
          const line = new THREE.Mesh(geo, mat);
          line.castShadow = true;
          scribbleGroup.add(line);
          scribbleLines.push({ curve, y, width });

          // åœ¨çº¿æ¡ä¸Šéšæœºæ”¾ç½®å‘å…‰ç‚¹ï¼ˆæ¥è¿‘ç¤ºä¾‹å›¾ä¸­çš„äº®ç‚¹ï¼‰
          const bulbCount = 6 + Math.floor(Math.random() * 4);
          for (let b = 0; b < bulbCount; b++) {
            const tt = Math.random();
            const p = curve.getPoint(tt);
            const bulbGeo = new THREE.SphereGeometry(0.12, 10, 10);
            const bulbMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.8 });
            const bulb = new THREE.Mesh(bulbGeo, bulbMat);
            bulb.position.copy(p);
            bulbs.push({ mesh: bulb, baseIntensity: 0.9, phase: Math.random() * Math.PI * 2 });
            treeGroup.add(bulb);
          }
        }
      }
      buildPinkScribbleTree();
      // ä»…ä¿ç•™ä¸‰ç»´æ ‘ä½“ï¼šéšè—æ‰‹ç»˜æ¨ªå‘ç¬”è§¦ï¼Œæ˜¾ç¤ºåœ†é”¥æ ‘å† 
      scribbleGroup.visible = false;
      foliageCones.forEach(({ mesh }) => { mesh.visible = true; if (mesh.material) { mesh.material.emissive?.setHex(0x000000); if ('emissiveIntensity' in mesh.material) mesh.material.emissiveIntensity = 0.0; } });

      // åœ¨æ ‘ä¸Šæ·»åŠ ç™½è‰²â€œé›ªèŠ±â€è£…é¥°ï¼ˆé™æ€ï¼‰
      function makeFlowerTexture() {
        const c = document.createElement('canvas');
        c.width = c.height = 64;
        const ctx = c.getContext('2d');
        ctx.clearRect(0,0,64,64);
        ctx.translate(32,32);
        ctx.fillStyle = 'rgba(255,255,255,0.95)';
        for (let i=0;i<6;i++) {
          ctx.rotate(Math.PI/3);
          ctx.beginPath();
          ctx.ellipse(16,0,8,3,0,0,Math.PI*2);
          ctx.fill();
        }
        const tex = new THREE.CanvasTexture(c);
        tex.colorSpace = THREE.SRGBColorSpace;
        return tex;
      }
      const flowerTex = makeFlowerTexture();
      const flowerMat = new THREE.SpriteMaterial({ map: flowerTex, color: 0xffffff, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending });
      for (let i = 0; i < 22; i++) {
        const pick = scribbleLines[Math.floor(Math.random() * scribbleLines.length)];
        const t = Math.random();
        const p = pick.curve.getPoint(t);
        const sp = new THREE.Sprite(flowerMat.clone());
        sp.scale.setScalar(0.8 + Math.random()*0.6);
        sp.position.copy(p.clone().add(new THREE.Vector3((Math.random()-0.5)*0.2, (Math.random()-0.5)*0.2, (Math.random()-0.5)*0.1)));
        treeGroup.add(sp);
      }

      // ç¤¼ç‰©ç›’ï¼ˆæ ‘åº•ï¼‰
      function addGift(x, z, color = 0xff6b6b) {
        const box = new THREE.Mesh(
          new THREE.BoxGeometry(0.9, 0.6, 0.9),
          new THREE.MeshPhysicalMaterial({ color, emissive: mixHexColor(color, 0xffffff, 0.72), emissiveIntensity: 0.26, roughness: 0.4, metalness: 0.2 })
        );
        box.position.set(x, 0.32, z);
        box.castShadow = true;
        scene.add(box);

        const ribbon = new THREE.Mesh(
          new THREE.TorusGeometry(0.48, 0.04, 10, 24),
          new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.6 })
        );
        ribbon.rotation.x = Math.PI / 2;
        ribbon.position.set(x, 0.62, z);
        scene.add(ribbon);
        // ç¤¼ç‰©ç›’æµ…æµ…åŒè‰²å…‰æ™•ï¼ˆå°èŒƒå›´ï¼‰
        const haloCol = mixHexColor(color, 0xffffff, 0.86);
        const halo = new THREE.Sprite(new THREE.SpriteMaterial({ map: makeHaloTexture('#ffffff'), color: haloCol, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending }));
        halo.scale.setScalar(0.3 + Math.random()*0.14);
        halo.position.set(x, 0.62, z);
        scene.add(halo);
      }
      addGift(2.2, 2.0, 0xff9090);
      addGift(-2.4, 1.6, 0x6fd3ff);
      addGift(-1.0, -2.2, 0xffc45c);

      // é›ªèŠ±å½¢çŠ¶ï¼ˆå‚è€ƒå›¾ç‰‡ï¼‰ï¼šç”Ÿæˆæ¸…æ™°çš„é›ªèŠ±çº¹ç†
      function makeSnowflakeTexture(variant = 0) {
        const c = document.createElement('canvas');
        c.width = c.height = 128;
        const ctx = c.getContext('2d');
        ctx.clearRect(0, 0, 128, 128);
        ctx.translate(64, 64);
        ctx.strokeStyle = 'white';
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        const lw = variant % 2 === 0 ? 6 : 4.5; // çº¿å®½å˜åŒ–
        ctx.lineWidth = lw;
        const arms = 6;
        const len = 36;
        for (let i = 0; i < arms; i++) {
          const ang = (Math.PI * 2 / arms) * i;
          ctx.save();
          ctx.rotate(ang);
          // ä¸»å¹²
          ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, -len); ctx.stroke();
          // åˆ†å‰
          const branchCount = 2 + (variant % 3);
          for (let b = 1; b <= branchCount; b++) {
            const t = -len * (b / (branchCount + 1));
            const bl = 12 + b * 4;
            ctx.beginPath(); ctx.moveTo(0, t); ctx.lineTo(bl * 0.6, t - 6); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, t); ctx.lineTo(-bl * 0.6, t - 6); ctx.stroke();
          }
          // ç«¯éƒ¨å½¢çŠ¶ï¼šåœ†ç‚¹æˆ–åå­—
          if (variant % 4 === 0) {
            ctx.beginPath(); ctx.arc(0, -len, lw, 0, Math.PI * 2); ctx.fillStyle = 'white'; ctx.fill();
          } else if (variant % 4 === 1) {
            ctx.beginPath(); ctx.moveTo(-lw, -len); ctx.lineTo(lw, -len); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, -len - lw); ctx.lineTo(0, -len + lw); ctx.stroke();
          }
          ctx.restore();
        }
        // ä¸­å¿ƒå°åœ†
        ctx.beginPath(); ctx.arc(0, 0, 6, 0, Math.PI * 2); ctx.fillStyle = 'white'; ctx.fill();
        const tex = new THREE.CanvasTexture(c); tex.colorSpace = THREE.SRGBColorSpace; tex.anisotropy = 4; return tex;
      }

      const snowflakeTexSet = [0,1,2,3,4].map(i => makeSnowflakeTexture(i));

const snowCount = 1000; // è¿œæ™¯é›ªèŠ±ç¨å‡ï¼Œæå‡æ€§èƒ½
      const snowGeo = new THREE.BufferGeometry();
      const snowPositions = new Float32Array(snowCount * 3);
      const snowVel = new Float32Array(snowCount);
      for (let i = 0; i < snowCount; i++) {
        snowPositions[i * 3 + 0] = (Math.random() - 0.5) * 40;
        snowPositions[i * 3 + 1] = Math.random() * 22 + 6;
        snowPositions[i * 3 + 2] = (Math.random() - 0.5) * 40;
  snowVel[i] = 0.026 + Math.random() * 0.052; // å†å¿«ä¸€ç‚¹ç‚¹
      }
      snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPositions, 3));
      // ä½¿ç”¨æ¸…æ™°çš„é›ªèŠ±çº¹ç†ï¼Œé¿å…è¿‡åº¦æ³›å…‰
      const snowMat = new THREE.PointsMaterial({ map: snowflakeTexSet[0], color: 0xffffff, size: 0.1, transparent: true, alphaTest: 0.5, opacity: 0.95, depthWrite: false, blending: THREE.NormalBlending });
      const snow = new THREE.Points(snowGeo, snowMat);
      scene.add(snow);

      // è¿œæ™¯é¢å¤–å›¾å±‚ï¼Œä½¿ç”¨å…¶å®ƒé›ªèŠ±æ¬¾å¼
      const snowExtras = [];
      for (let layer = 1; layer <= 3; layer++) {
        const count = 600;
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(count * 3);
        const vel = new Float32Array(count);
        for (let i = 0; i < count; i++) {
          pos[i * 3 + 0] = (Math.random() - 0.5) * 40;
          pos[i * 3 + 1] = Math.random() * 22 + 6;
          pos[i * 3 + 2] = (Math.random() - 0.5) * 40;
          vel[i] = 0.02 + Math.random() * 0.045;
        }
        geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        const mat = new THREE.PointsMaterial({ map: snowflakeTexSet[layer], color: 0xffffff, size: 0.1, transparent: true, alphaTest: 0.5, opacity: 0.95, depthWrite: false, blending: THREE.NormalBlending });
        const points = new THREE.Points(geo, mat);
        scene.add(points);
        snowExtras.push({ geo, vel, count });
      }

      // è¿‘æ™¯é›ªèŠ±å±‚ï¼šæ›´å¤§çš„é¢—ç²’ä¸è½»å¾®é£é£˜ï¼Œå¢åŠ å±å¹•ä¸Šçš„é£˜è½æ„Ÿ
const snowNearCount = 180;
      const snowNearGeo = new THREE.BufferGeometry();
      const snowNearPositions = new Float32Array(snowNearCount * 3);
      const snowNearVel = new Float32Array(snowNearCount);
      const snowNearPhase = new Float32Array(snowNearCount);
      for (let i = 0; i < snowNearCount; i++) {
        snowNearPositions[i * 3 + 0] = (Math.random() - 0.5) * 30;
        snowNearPositions[i * 3 + 1] = Math.random() * 20 + 8;
        snowNearPositions[i * 3 + 2] = (Math.random() - 0.5) * 30;
  snowNearVel[i] = 0.042 + Math.random() * 0.07; // å†å¿«ä¸€ç‚¹ç‚¹
        snowNearPhase[i] = Math.random() * Math.PI * 2;
      }
      snowNearGeo.setAttribute('position', new THREE.BufferAttribute(snowNearPositions, 3));
      const snowNearMat = new THREE.PointsMaterial({ map: snowflakeTexSet[4], color: 0xffffff, size: 0.18, transparent: true, alphaTest: 0.5, opacity: 0.95, depthWrite: false, blending: THREE.NormalBlending });
      const snowNear = new THREE.Points(snowNearGeo, snowNearMat);
      scene.add(snowNear);

      // æ¯›èŒ¸èŒ¸è¾¹ç¼˜ï¼ˆSprite ç²’å­æ¨¡æ‹Ÿæ‰‹ç»˜ç¾½åŒ–ï¼‰
      const fuzzSprites = [];
      function makeFuzzTexture(color = '#ffffff') {
        const c = document.createElement('canvas');
        c.width = c.height = 64;
        const ctx = c.getContext('2d');
        const g = ctx.createRadialGradient(32, 32, 10, 32, 32, 32);
        g.addColorStop(0, color);
        g.addColorStop(0.6, 'rgba(255,255,255,0.65)');
        g.addColorStop(1, 'rgba(255,255,255,0.0)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(32, 32, 32, 0, Math.PI * 2);
        ctx.fill();
        const tex = new THREE.CanvasTexture(c);
        tex.colorSpace = THREE.SRGBColorSpace;
        return tex;
      }

      function buildFuzzSprites(tint = 0xffffff, densityFactor = 1.0) {
        fuzzSprites.forEach(s => treeGroup.remove(s));
        fuzzSprites.length = 0;
        const tex = makeFuzzTexture('#ffffff');
        const mat = new THREE.SpriteMaterial({ map: tex, color: tint, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending });
        foliageCones.forEach(({ mesh, radius, height }) => {
          const count = Math.floor(70 * densityFactor);
          for (let i = 0; i < count; i++) {
            const t = Math.random();
            const yLocal = (t * 0.9 + 0.05) * height - height / 2;
            const ang = Math.random() * Math.PI * 2;
            const r = radius * (1 - (yLocal + height / 2) / height * 0.9) * (1 + (Math.random() - 0.5) * 0.08);
            const s = new THREE.Sprite(mat.clone());
            s.scale.setScalar(0.9 + Math.random() * 0.5);
            s.position.set(mesh.position.x + Math.cos(ang) * r, mesh.position.y + yLocal + (Math.random() - 0.5) * 0.2, mesh.position.z + Math.sin(ang) * r);
            fuzzSprites.push(s);
            treeGroup.add(s);
          }
        });
      }

      // åæœŸï¼šBloomï¼ˆæå‡å‘å…‰ä¸æŸ”å’Œæ„Ÿï¼‰
      const composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(scene, camera));
      const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.6, 0.6, 0.02);
      composer.addPass(bloomPass);

      // é£æ ¼é¢„è®¾ï¼ˆæŒ‰ 1/2/3/4 å¿«æ·é”®åˆ‡æ¢ï¼‰
      const styles = {
        pink: {
          foliageColor: 0xff8fc7,
          bulbColors: [0xffffff, 0xffe6a8, 0xffb3d1, 0xfff5f5],
          garlandColor: 0xffffff,
          starColor: 0xfff3a0,
          fuzzTint: 0xfff7f7,
          bloomStrength: 1.35,
        },
        green: {
          foliageColor: 0x2fa84e,
          bulbColors: [0xff3b3b, 0x3b9cff, 0xffa600, 0x9b59ff, 0x3cff8f],
          garlandColor: 0xff314a,
          starColor: 0xffd34f,
          fuzzTint: 0xd6ffd6,
          bloomStrength: 0.8,
        },
        blue: {
          foliageColor: 0x53b6ff,
          bulbColors: [0xa0d8ff, 0xeaf6ff, 0x7cc8ff, 0x9a77ff],
          garlandColor: 0xaad6ff,
          starColor: 0x9ad9ff,
          fuzzTint: 0xe6f6ff,
          bloomStrength: 1.4,
        },
        white: {
          foliageColor: 0xe8f2ff,
          bulbColors: [0xfff2bf, 0xffd6d6, 0xc7f5ff, 0xffffff],
          garlandColor: 0xffffff,
          starColor: 0xffffcc,
          fuzzTint: 0xffffff,
          bloomStrength: 1.5,
        }
      };

      function applyStyle(name) {
        const s = styles[name] || styles.green;
        // æ›´æ–°å¶å­å±‚é¢œè‰²
        treeGroup.children.forEach((child) => {
          if (child instanceof THREE.Mesh && child.geometry instanceof THREE.ConeGeometry) {
            child.material.color.setHex(s.foliageColor);
          }
        });
        // æ›´æ–°èºæ—‹å½©å¸¦
        garland.material.color.setHex(s.garlandColor);
        // æ›´æ–°æ˜Ÿæ˜Ÿ
        star.material.color.setHex(s.starColor);
        star.material.emissive.setHex(s.starColor);
        // æ›´æ–°ç¯ç¯é¢œè‰²
        lightGroup.children.forEach((m, i) => {
          const c = s.bulbColors[i % s.bulbColors.length];
          m.material.color.setHex(c);
          m.material.emissive.setHex(c);
        });
        // æ›´æ–°æ•£è½å½©çƒ
        bulbs.forEach((b, i) => {
          const c = s.bulbColors[i % s.bulbColors.length];
          b.mesh.material.color.setHex(c);
          b.mesh.material.emissive.setHex(c);
        });
        // å…³é—­ Fuzz æ¯›è¾¹ï¼Œé¿å…æ ‘ä½“æ•´ä½“å‘å…‰
        fuzzSprites.forEach(s => treeGroup.remove(s));
        fuzzSprites.length = 0;
        // Bloom å¼ºåº¦
        bloomPass.strength = s.bloomStrength;
      }

      // é»˜è®¤é£æ ¼ï¼šç²‰è‰²ï¼ˆä¸å½“å‰å‚è€ƒå›¾åŒ¹é…ï¼‰
      applyStyle('pink');

      // ä»…è®©â€œç¯æ³¡â€å‘å…‰ï¼šæŒ‰ L ä»…è°ƒæ•´ç¯æ³¡äº®åº¦ï¼ˆæ ‘ä½“ä¸å½©å¸¦ä¸å‘å…‰ï¼‰
      let lightingMode = 'subtle';
      function setLightingMode(mode) {
        lightingMode = mode;
        const isVivid = mode === 'vivid';
        // ä»…è°ƒç¯æ³¡äº®åº¦
        lightGroup.children.forEach(m => { const mat = m.material; if (mat) mat.emissiveIntensity = isVivid ? 0.9 : 0.6; });
        bulbs.forEach(b => { b.mesh.material.emissiveIntensity = isVivid ? 0.85 : 0.6; b.baseIntensity = isVivid ? 0.7 : 0.5; });
        // æ˜Ÿæ˜Ÿå¯å¾®äº®ï¼ˆå¯åˆ‡æ¢ï¼‰
        star.material.emissiveIntensity = isVivid ? 0.2 : 0.1;
        // Bloom é€‚åº¦
        bloomPass.strength = isVivid ? 0.7 : 0.5;
        // åœ¨æ¨¡å¼åˆ‡æ¢åé‡æ–°æŒ‰å¯†åº¦å°å¹…è¡°å‡ï¼Œç¡®ä¿â€œå¯†é›†åŒºåŸŸç•¥æš—â€çš„æ•ˆæœæŒç»­ç”Ÿæ•ˆ
        applyDensityDampening();
      }
      setLightingMode('subtle');
      window.addEventListener('keydown', (e) => { if (e.key.toLowerCase() === 'l') setLightingMode(lightingMode === 'subtle' ? 'vivid' : 'subtle'); });

      // å¼€å…³ï¼šä»…ç¯æ³¡å‘å…‰ï¼ˆBï¼‰ï¼Œæ˜Ÿæ˜Ÿå‘å…‰ï¼ˆSï¼‰
      let onlyBulbsGlow = false; // é»˜è®¤è®©æ˜Ÿæ˜Ÿä¹Ÿæ˜äº®
      function applyGlowPolicy() {
        // æ ‘å¹²/æ ‘å† ä¸å‘å…‰
        foliageCones.forEach(({ mesh }) => { if (mesh.material) { mesh.material.emissive?.setHex(0x000000); if ('emissiveIntensity' in mesh.material) mesh.material.emissiveIntensity = 0.0; } });
        trunk.material.emissive?.setHex(0x000000);
        if ('emissiveIntensity' in trunk.material) trunk.material.emissiveIntensity = 0.0;
        // å½©å¸¦ä¸å‘å…‰
        tubeMat.emissiveIntensity = 0.0;
        // æ˜Ÿæ˜Ÿæ ¹æ®ç­–ç•¥å‘å…‰ä¸å¦
        star.material.emissiveIntensity = onlyBulbsGlow ? 0.0 : 1.2;
      }
      applyGlowPolicy();

      // å¯†é›†åŒºåŸŸå°å¹…é™ä½äº®åº¦ï¼ˆä¸€æ¬¡æ€§é¢„å¤„ç† + åœ¨æ¨¡å¼åˆ‡æ¢æ—¶é‡ç”¨ï¼‰
      function applyDensityDampening(opts = {}) {
        const radius = opts.radius ?? 0.35;      // åˆ¤å®šâ€œå¯†é›†â€çš„é‚»è¿‘è·ç¦»ï¼ˆä¸–ç•Œåæ ‡ï¼‰
        const threshold = opts.threshold ?? 7;   // é‚»å±…æ•°é‡é˜ˆå€¼ï¼ˆè¾¾åˆ°æˆ–è¶…è¿‡åˆ™è®¤ä¸ºå¯†é›†ï¼‰
        const factor = opts.factor ?? 0.92;      // äº®åº¦è¡°å‡ç³»æ•°ï¼ˆä¿ç•™åŸæœ¬ 92%ï¼‰
        if (!Array.isArray(bulbs) || bulbs.length === 0) return;
        const tmp = new THREE.Vector3();
        const positions = bulbs.map(b => { const v = new THREE.Vector3(); b.mesh.getWorldPosition(v); return v; });
        const counts = new Array(bulbs.length).fill(0);
        for (let i = 0; i < bulbs.length; i++) {
          for (let j = i + 1; j < bulbs.length; j++) {
            if (positions[i].distanceTo(positions[j]) < radius) { counts[i]++; counts[j]++; }
          }
        }
        bulbs.forEach((b, i) => {
          if (counts[i] >= threshold) {
            b.baseIntensity = (b.baseIntensity ?? 0.6) * factor;
            const mat = b.mesh.material;
            if (mat && 'emissiveIntensity' in mat) mat.emissiveIntensity = Math.max(0.15, (mat.emissiveIntensity ?? 0.6) * factor);
            b._dense = 1;
          }
        });
      }
      // åˆæ¬¡åº”ç”¨ï¼šåœ¨é»˜è®¤â€œsubtleâ€æ¨¡å¼è®¾ç½®ä¹‹åè°ƒç”¨ä¸€æ¬¡
      applyDensityDampening();
      window.addEventListener('keydown', (e) => {
        if (e.key.toLowerCase() === 'b') { onlyBulbsGlow = !onlyBulbsGlow; applyGlowPolicy(); }
        if (e.key.toLowerCase() === 's') { star.material.emissiveIntensity = star.material.emissiveIntensity > 0 ? 0.0 : 1.2; }
      });
      // å¿«æ·é”®ï¼š1 ç²‰è‰² | 2 ç»¿è‰² | 3 è“è‰² | 4 ç™½è‰²
      window.addEventListener('keydown', (e) => {
        if (e.key === '1') applyStyle('pink');
        else if (e.key === '2') applyStyle('green');
        else if (e.key === '3') applyStyle('blue');
        else if (e.key === '4') applyStyle('white');
      });

      let autorotate = true;
      // é‡‡ç”¨â€œæ—¶é—´é©±åŠ¨â€çš„æ—‹è½¬ï¼Œé¿å…å¸§ç‡æ³¢åŠ¨é€ æˆè§’åº¦å¢é‡æŠ–åŠ¨ï¼Œæå‡ä¸æ»‘æ„Ÿ
      let rotationBase = treeGroup.rotation.y;
      let rotationStartTime = 0;
      // é”®ç›˜ R å¯åˆ‡æ¢æ—‹è½¬ï¼›ç‚¹å‡»ç”»é¢åˆ™åœæ­¢ï¼ˆç¬¦åˆâ€œè‡ªåŠ¨è½¬èµ·æ¥æˆ‘ç‚¹å‡»æ‰åœæ­¢â€ï¼‰
      window.addEventListener('keydown', (e) => {
        if (e.key.toLowerCase() === 'r') {
          autorotate = !autorotate;
          if (autorotate) { rotationBase = treeGroup.rotation.y; rotationStartTime = clock.getElapsedTime(); }
        }
      });
      renderer.domElement.addEventListener('pointerdown', () => { autorotate = false; rotationBase = treeGroup.rotation.y; });
      // åˆå§‹åŒ–ç³–æœæŒ‰é’®çš„è§†è§‰çŠ¶æ€ï¼ˆæ­¤æ—¶ autorotate å·²å£°æ˜ï¼‰
      try { updateCandyVisual(); } catch {}

      const clock = new THREE.Clock();
      // æ€§èƒ½è‡ªé€‚åº”ï¼šæ ¹æ®å¹³å‡å¸§ç‡åŠ¨æ€è¿›å…¥â€œä½å¼€é”€æ¨¡å¼â€ï¼Œé™ä½éƒ¨åˆ†æ›´æ–°é¢‘ç‡ä¸åæœŸå¤„ç†å¼€é”€
      let perfMode = false; // ä½å¼€é”€æ¨¡å¼æ ‡è®°
      let fpsAvg = 60; // æŒ‡æ•°å¹³æ»‘çš„å¹³å‡å¸§ç‡
      let lastPerfSwitch = 0; // ä¸Šæ¬¡æ¨¡å¼åˆ‡æ¢æ—¶é—´æˆ³
      // åŸºäºæ—¶é—´çš„æ ‘æ—‹è½¬ï¼Œä¸”ä¸æµæ˜Ÿï¼ˆ~1.35sï¼‰å’Œè´è¶æ‰‡åŠ¨ï¼ˆ~0.9sï¼‰çš„å¹³å‡èŠ‚å¥è°è°ƒï¼šä¸€åœˆ 27sï¼ˆ=20Ã—1.35s=30Ã—0.9sï¼‰
      const wingAvgPeriodSec = 0.9;
      const meteorAvgPeriodSec = 1.35;
      const harmonizedPeriodSec = 27; // ä¸ä¸¤è€…è°è°ƒçš„å‘¨æœŸ
      const baseOmega = (Math.PI * 2) / harmonizedPeriodSec;
      const syncAmp = THREE.MathUtils.degToRad(3.2); // ç»†å¾®è§’åº¦æ‘†åŠ¨ï¼Œéšè´è¶æ‹æ‰“åŒæ­¥
      function animate() {
        const t = clock.getElapsedTime();
        const dt = clock.getDelta();
        // å¸§ç‡å¹³æ»‘è®¡ç®—
        const fps = 1 / Math.max(0.000001, dt);
        fpsAvg = fpsAvg * 0.9 + fps * 0.1;
        // æ¯ 0.6s è¯„ä¼°ä¸€æ¬¡æ˜¯å¦åˆ‡æ¢æ€§èƒ½æ¨¡å¼ï¼Œé¿å…æŠ–åŠ¨
        if (!animate._lastCheck || (t - animate._lastCheck) > 0.6) {
          animate._lastCheck = t;
          if (!perfMode && fpsAvg < 45 && (t - lastPerfSwitch) > 2) {
            perfMode = true; lastPerfSwitch = t;
            renderer.setPixelRatio(1.0); // è¿›å…¥ä½å¼€é”€æ¨¡å¼é™ä½åƒç´ æ¯”
            if (typeof bloomPass !== 'undefined') {
              bloomPass.strength = 0.28; // åŸ 0.6 â†’ 0.28
              bloomPass.radius = 0.28;   // åŸ 0.6 â†’ 0.28
              bloomPass.threshold = 0.06; // åŸ 0.02 â†’ ç•¥æé«˜é˜ˆå€¼
            }
          } else if (perfMode && fpsAvg > 55 && (t - lastPerfSwitch) > 4) {
            perfMode = false; lastPerfSwitch = t;
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.35)); // æ¢å¤é»˜è®¤åƒç´ æ¯”
            if (typeof bloomPass !== 'undefined') {
              bloomPass.strength = 0.45; // æ¢å¤åˆ°è¾ƒä¸­åº¸çš„å¼ºåº¦ä»¥æ§åˆ¶å¼€é”€
              bloomPass.radius = 0.4;
              bloomPass.threshold = 0.04;
            }
          }
        }
        requestAnimationFrame(animate);
        controls.update();
        if (autorotate) {
          if (rotationStartTime === 0) { rotationBase = treeGroup.rotation.y; rotationStartTime = t; }
          const elapsed = t - rotationStartTime;
          treeGroup.rotation.y = rotationBase + baseOmega * elapsed + syncAmp * Math.sin((elapsed / wingAvgPeriodSec) * Math.PI * 2);
        }
        // ç²’å­å…‰æ™•å‘¼å¸ä¸è½»å¾®é—ªçƒ
        const haloPosAttr = haloGeo.attributes.position;
        const haloColAttr = haloGeo.attributes.color;
        const breath = particleControl.paused ? 0 : (1 + Math.sin(t * 0.6) * 0.035);
        treeHalo.scale.set(breath, breath, breath);
        // ä½å¼€é”€æ¨¡å¼ä¸‹éš”å¸§æ›´æ–°é¢œè‰²ï¼Œé™ä½ BufferAttribute å†™å…¥é¢‘ç‡
        if (!perfMode || (perfMode && ((animate._frame || 0) % 2 === 0))) {
          for (let i=0;i<haloCount;i++) {
            const flick = particleControl.paused ? 1.0 : (0.9 + Math.sin(t * 2.0 + haloPhase[i]) * 0.08); // è½»å¾®äº®åº¦æ³¢åŠ¨
            haloColAttr.array[i*3+0] = haloColBase[i*3+0] * flick;
            haloColAttr.array[i*3+1] = haloColBase[i*3+1] * flick;
            haloColAttr.array[i*3+2] = haloColBase[i*3+2] * flick;
          }
          haloColAttr.needsUpdate = true;
        }
        // èºæ—‹ç¯å½¢å…‰å¸¦ç»•åœˆä¸é—ªçƒï¼ˆå‘¼å¸æ„Ÿï¼‰
        const ringPosAttr = ringGeo.attributes.position;
        const ringColAttr = ringGeo.attributes.color;
        const omega = 0.9 * particleControl.speedScale;
        if (!perfMode || (perfMode && ((animate._frame || 0) % 2 === 0))) {
          for (let i=0;i<ringCount;i++) {
            const tP = ringT[i];
            const y = yMin + tP * (yMax - yMin);
            const r = treeRadiusAtY(y) * 1.05;
            const phi = ringPhi0[i] + (particleControl.paused ? 0 : (t * omega * Math.PI * 2));
            ringPosAttr.array[i*3+0] = Math.cos(phi) * r;
            ringPosAttr.array[i*3+1] = y;
            ringPosAttr.array[i*3+2] = Math.sin(phi) * r;
            // è½»å¾®é—ªçƒï¼ˆé€šè¿‡é¢œè‰²äº®åº¦å˜åŒ–æ¨¡æ‹Ÿ opacity å‘¼å¸ï¼‰
            const flick = particleControl.paused ? 1.0 : (0.88 + Math.sin(t * 2.4 + ringPhase[i]) * 0.12);
            ringColAttr.array[i*3+0] = ringColBase[i*3+0] * flick;
            ringColAttr.array[i*3+1] = ringColBase[i*3+1] * flick;
            ringColAttr.array[i*3+2] = ringColBase[i*3+2] * flick;
          }
          ringPosAttr.needsUpdate = true;
          ringColAttr.needsUpdate = true;
        }
        if (!perfMode || (perfMode && ((animate._frame || 0) % 2 === 0))) {
          bulbs.forEach(b => {
            const intensity = b.baseIntensity + Math.sin(t * 2.4 + b.phase) * 0.18;
            b.mesh.material.emissiveIntensity = Math.max(0.15, intensity);
          });
        }
        const pos = snowGeo.attributes.position;
        for (let i = 0; i < snowCount; i++) {
          pos.array[i * 3 + 1] -= snowVel[i];
          if (pos.array[i * 3 + 1] < 0) {
            pos.array[i * 3 + 0] = (Math.random() - 0.5) * 40;
            pos.array[i * 3 + 1] = Math.random() * 18 + 8;
            pos.array[i * 3 + 2] = (Math.random() - 0.5) * 40;
          }
        }
        pos.needsUpdate = true;
        // è¿œæ™¯é¢å¤–é›ªèŠ±å›¾å±‚æ›´æ–°
        snowExtras.forEach(layer => {
          const posE = layer.geo.attributes.position;
          for (let i = 0; i < layer.count; i++) {
            posE.array[i * 3 + 1] -= layer.vel[i];
            if (posE.array[i * 3 + 1] < 0) {
              posE.array[i * 3 + 0] = (Math.random() - 0.5) * 40;
              posE.array[i * 3 + 1] = Math.random() * 22 + 6;
              posE.array[i * 3 + 2] = (Math.random() - 0.5) * 40;
              layer.vel[i] = 0.02 + Math.random() * 0.045;
            }
          }
          posE.needsUpdate = true;
        });
      // è¿‘æ™¯é›ªèŠ±é£é£˜ä¸ä¸‹è½
      const posN = snowNearGeo.attributes.position;
      for (let i = 0; i < snowNearCount; i++) {
        // é£å‘éšæ—¶é—´è½»å¾®å˜åŒ–
        const wind = Math.sin(t * 0.4 + snowNearPhase[i]) * 0.02;
        posN.array[i * 3 + 0] += wind;
        posN.array[i * 3 + 1] -= snowNearVel[i];
        if (posN.array[i * 3 + 1] < 0) {
          posN.array[i * 3 + 0] = (Math.random() - 0.5) * 30;
          posN.array[i * 3 + 1] = Math.random() * 20 + 8;
          posN.array[i * 3 + 2] = (Math.random() - 0.5) * 30;
        }
      }
      posN.needsUpdate = true;
        // è´è¶ç¿…è†€æ‰‡åŠ¨ä¸é£è¡Œ/åœé©»æ›´æ–°ï¼ˆå‰ç¿…/åç¿…é”™è½ï¼Œé¡¶å³°è½»å¾®é¢¤åŠ¨ï¼Œè†œæ³¢çº¹ï¼‰
        butterflies.forEach(b => {
          const flapFore = Math.sin(t * b.flapSpeed + (b.phase || 0));
          const flapHind = Math.sin(t * b.flapSpeed + (b.phase || 0) + 0.35); // åç¿…ç•¥æ»å

          const baseFore = 0.55, ampFore = 0.52;
          const baseHind = 0.45, ampHind = 0.48;
          if (b.leftForePivot) b.leftForePivot.rotation.z = baseFore + flapFore * ampFore;
          if (b.rightForePivot) b.rightForePivot.rotation.z = -baseFore - flapFore * ampFore;
          if (b.leftHindPivot) b.leftHindPivot.rotation.z = baseHind + flapHind * ampHind;
          if (b.rightHindPivot) b.rightHindPivot.rotation.z = -baseHind - flapHind * ampHind;

          // é¡¶å³°é¢¤åŠ¨ï¼šæ¥è¿‘å³°å€¼æ—¶åŠ å…¥å¾®å°æŠ–åŠ¨
          const jitter = (x) => (Math.abs(x) > 0.96 ? (Math.random()-0.5) * 0.06 : 0);
          if (b.leftForePivot) b.leftForePivot.rotation.z += jitter(flapFore);
          if (b.rightForePivot) b.rightForePivot.rotation.z -= jitter(flapFore);
          if (b.leftHindPivot) b.leftHindPivot.rotation.z += jitter(flapHind);
          if (b.rightHindPivot) b.rightHindPivot.rotation.z -= jitter(flapHind);

          // è†œæ³¢çº¹ï¼šéšæ‰‡åŠ¨å¯¹æœºç¿¼æ–½åŠ è½»å¾®çš„ x/y æ—‹è½¬ä¸ç¼©æ”¾å˜åŒ–
          const rippleFore = Math.sin(t * b.flapSpeed * 2 + (b.phase || 0)) * 0.08;
          const rippleHind = Math.sin(t * b.flapSpeed * 2 + (b.phase || 0) + 0.6) * 0.08;
          if (b.leftForePivot && b.leftForePivot.children[0]) { const w = b.leftForePivot.children[0]; w.rotation.x = rippleFore; w.scale.y = 1 + rippleFore * 0.06; }
          if (b.rightForePivot && b.rightForePivot.children[0]) { const w = b.rightForePivot.children[0]; w.rotation.x = rippleFore; w.scale.y = 1 + rippleFore * 0.06; }
          if (b.leftHindPivot && b.leftHindPivot.children[0]) { const w = b.leftHindPivot.children[0]; w.rotation.x = rippleHind; w.scale.y = 1 + rippleHind * 0.06; }
          if (b.rightHindPivot && b.rightHindPivot.children[0]) { const w = b.rightHindPivot.children[0]; w.rotation.x = rippleHind; w.scale.y = 1 + rippleHind * 0.06; }

          // é£è¡Œ/åœé©»è¡Œä¸º
          if (b.mode === 'around') {
            b.angle += dt * b.flySpeed;
            b.group.position.x = Math.cos(b.angle) * b.radius;
            b.group.position.z = Math.sin(b.angle) * b.radius;
            b.group.position.y = b.baseY + Math.sin(t * 0.8 + (b.phase || 0)) * 0.7;
            b.group.rotation.y = -b.angle + Math.PI/2;
          } else {
            // åœé©»ï¼Œæè½»æŠ–åŠ¨
            b.group.position.y += Math.sin(t * 1.15 + (b.phase || 0)) * 0.003;
          }
        });
        // æ˜Ÿæ˜Ÿé—ªå…‰åŠ¨ç”»ï¼šå›´ç»•æ˜Ÿæ˜Ÿç¼“æ…¢æ—‹è½¬å¹¶é—ªçƒ
        sparkles.forEach(sp => {
          sp.angle += sp.speed * dt * 0.6;
          const x = star.position.x + Math.cos(sp.angle) * sp.radius;
          const z = star.position.z + Math.sin(sp.angle) * sp.radius;
          sp.sprite.position.x = x;
          sp.sprite.position.z = z;
          sp.sprite.material.opacity = 0.4 + Math.abs(Math.sin(t * 2.2 + sp.phase)) * 0.6;
        });
        // åº•å±‚æ‚¬æŒ‚æŒ‚ä»¶ï¼šè½»å¾®æ‘†åŠ¨ä¸é—ªäº®æ•ˆæœ
        bottomHangings.forEach(h => {
          h.rotation.z = Math.sin(t * 1.1 + (h._swayPhase || 0)) * (h._swayAmp || 0.08);
          if (h._sparkle) {
            h._sparkle.material.opacity = 0.6 + Math.abs(Math.sin(t * 2.0 + (h._swayPhase || 0))) * 0.4;
          }
          if (h._sparkle2) {
            h._sparkle2.material.opacity = 0.5 + Math.abs(Math.sin(t * 2.6 + (h._swayPhase || 0) + 0.6)) * 0.5;
          }
        });
        // çº¦æ¯ 10 å¸§æ›´æ–°ä¸€æ¬¡ç¥ç¦è¯­ä½ç½®ï¼š
        // A) å³ä¾§ï¼šä¸é«˜äºç¬¬å››å±‚ï¼ˆç•¥ä½ 28pxï¼‰ã€ä¸‹ç§»åç½®ï¼ˆ4% é«˜åº¦ï¼‰ã€é˜²äº¤é”™ï¼ˆç›¸é‚»è‡³å°‘ 26pxï¼‰
        // B) å·¦ä¾§ï¼šè§„åˆ™åŒå³ä¾§ï¼Œä¿æŒä¸é‡å ä¸é ä¸‹çš„é”™è½åˆ†å¸ƒ
        if (!animate._frame) animate._frame = 0; animate._frame++;
        if (animate._frame % 10 === 0) {
          // é˜ˆå€¼æ”¹ä¸ºâ€œæ ‘å¹²é¡¶éƒ¨çš„ä¸–ç•Œé«˜åº¦â€ï¼Œç¡®ä¿ä¸‹é¢éƒ¨åˆ†çš„å­—æ•´ä½“ä¸‹ç§»æ—¶ä¸ä¼šé«˜äºæ ‘å¹²çš„æœ¬æ¥é«˜åº¦
          const rect = overlay.getBoundingClientRect();
          const trunkTopY = trunk.position.y + (trunkGeo.parameters?.height || 3.2) / 2;
          const thresholdPx = worldYToScreenY(trunkTopY);
          const downBias = rect.height * 0.04; // å†ä¸‹ç§»ä¸€ç‚¹
          const minGap = 26;
          function ensureNoOverlap(elements, extraDownBiasPx = 0) {
            // è¯»å–å½“å‰ top å¹¶æŒ‰ä½ç½®æ’åºï¼Œä¼˜å…ˆä¿ç•™ç”¨æˆ·ç§»åŠ¨è¿‡çš„å…ƒç´ ä½ç½®ä¸å˜
            const items = elements.map(el => {
              const current = el.style.top || '0px';
              let topPx = 0;
              if (current.endsWith('%')) topPx = parseFloat(current) / 100 * rect.height; else topPx = parseFloat(current) || 0;
              const minTop = thresholdPx + downBias + extraDownBiasPx;
              const fixed = el.dataset.userMoved === '1';
              return { el, topPx, desired: fixed ? topPx : Math.max(topPx, minTop), fixed };
            }).sort((a, b) => a.topPx - b.topPx);
            let lastTop = 0; let first = true;
            for (const it of items) {
              const tPx = it.fixed ? it.topPx : (first ? it.desired : Math.max(it.desired, lastTop + minGap));
              it.el.style.top = `${tPx}px`;
              lastTop = tPx; first = false;
            }
          }
          // å³ä¸‹è§’çš„å­—ï¼šæ•´ä½“ä¸‹ç§»åˆ°åŸæ¥ä½ç½®ä½ä¸€åŠï¼ˆåªåº”ç”¨ä¸€æ¬¡ï¼‰ï¼Œå¹¶ä¿æŒä¸é«˜äºæ ‘å¹²é¡¶ç«¯
          blessingElements.forEach(el => {
            if (el.dataset.shiftApplied === '1') return;
            let baseTopPx = 0;
            if (el.dataset.baseTopPercent) baseTopPx = parseFloat(el.dataset.baseTopPercent) / 100 * rect.height;
            else {
              const current = el.style.top || '0px';
              if (current.endsWith('%')) baseTopPx = parseFloat(current) / 100 * rect.height; else baseTopPx = parseFloat(current) || 0;
            }
            const targetTop = Math.max(baseTopPx + baseTopPx * 0.5, thresholdPx + downBias);
            el.style.top = `${targetTop}px`;
            el.dataset.shiftApplied = '1';
          });
        // é˜²äº¤é”™ä¸ä¸é«˜äºé˜ˆå€¼çš„æ•´ç†ï¼ˆå³ä¾§ä¸å·¦ä¾§ï¼‰
        ensureNoOverlap(blessingElements, 0);
        ensureNoOverlap(leftBlessingElements, 0);
          // å³ä¸‹è§’çš„å¥å­ä¸èƒ½è¶…å‡ºå±å¹•ï¼›è‹¥è¶…å‡ºåˆ™ç§»è‡³â€œæ ‘ä¸­å¿ƒä¸‹æ–¹â€çš„ä½ç½®ï¼ˆåªé’ˆå¯¹è¶…å‡ºè€…ï¼‰
          const treeRect = getTreeScreenRect();
          blessingElements.forEach(el => {
            if (el.dataset.userMoved === '1') return; // ç”¨æˆ·ç§»åŠ¨è¿‡çš„ä¸å†è‡ªåŠ¨é‡å®šä½
            const topStyle = el.style.top || '0px';
            const rectEl = el.getBoundingClientRect();
            const topPx = topStyle.endsWith('%') ? (parseFloat(topStyle) / 100 * rect.height) : (parseFloat(topStyle) || rectEl.top);
            const overflows = (topPx + rectEl.height) > (rect.height - 6);
            if (overflows) {
              // å±…ä¸­åˆ°æ ‘çš„ä¸‹æ–¹ä½ç½®
              const centerX = (treeRect.minX + treeRect.maxX) / 2;
              const targetTop = Math.min(rect.height - rectEl.height - 6, treeRect.maxY + 14);
              const targetLeft = Math.max(6, Math.min(rect.width - rectEl.width - 6, centerX - rectEl.width / 2));
              el.style.right = 'auto';
              el.style.left = `${targetLeft}px`;
              el.style.top = `${targetTop}px`;
              el.dataset.relocated = '1';
            }
          });
        }
        // æµæ˜Ÿä¸‹è½ä¸å‘¼å¸é—ªè€€
        meteors.forEach(m => {
          const s = m.sprite;
          s.position.x += m.vx * dt * 60;
          s.position.y -= m.vy * dt * 60;
          // è½»å¾®å‘¼å¸æ„Ÿäº®åº¦
          s.material.opacity = 0.75 + Math.abs(Math.sin(t * 2.0 + m.phase)) * 0.25;
          // é‡ç½®
          if (s.position.y < 0 || Math.abs(s.position.x) > 30) {
            s.position.set((Math.random()-0.5)*26, topY + 2 + Math.random()*2, -18);
            m.vy = 0.9 + Math.random()*1.4; m.vx = -0.15 + (Math.random()-0.5)*0.12; m.phase = Math.random()*Math.PI*2;
          }
        });
        if (perfMode) {
          // ä½å¼€é”€æ¨¡å¼ä¸‹ç»•è¿‡åæœŸå¤„ç†ï¼Œç›´æ¥æ¸²æŸ“
          renderer.render(scene, camera);
        } else {
          composer.render();
        }
      }
      animate();

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
        // é‡æ–°é€‚é…æ‘„åƒæœºï¼Œä¿è¯ç¼©æ”¾æ—¶ä»èƒ½å®Œæ•´çœ‹åˆ°æ ‘
        fitCameraToTreeGroup({ margin: 1.14 });
      });
    </script>
  </body>
</html>