```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Pixel Studio</title>
    <!-- å¼•å…¥ gif.js åº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
    <style>
        :root {
            --bg: #1a1b26;
            --panel: #24283b;
            --accent: #7aa2f7;
            --text: #a9b1d6;
            --border: #414868;
            --grid-line: rgba(255, 255, 255, 0.05);
        }

        * { box-sizing: border-box; user-select: none; }
        body {
            margin: 0; height: 100vh; background: var(--bg); color: var(--text);
            font-family: 'Courier New', Courier, monospace;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }

        /* é¡¶éƒ¨å·¥å…·æ  */
        .toolbar {
            display: flex; gap: 10px; margin-bottom: 15px;
            background: var(--panel); padding: 10px 20px; border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3); border: 1px solid var(--border);
        }
        
        .tool-group { display: flex; gap: 5px; align-items: center; padding: 0 10px; border-right: 1px solid var(--border); }
        .tool-group:last-child { border-right: none; }

        button {
            background: var(--bg); border: 1px solid var(--border); color: var(--text);
            padding: 8px 12px; cursor: pointer; border-radius: 6px; font-family: inherit;
            transition: 0.2s; display: flex; align-items: center; gap: 5px; font-size: 14px;
        }
        button:hover { background: var(--accent); color: #fff; border-color: var(--accent); }
        button.active { background: var(--accent); color: #fff; box-shadow: inset 0 2px 5px rgba(0,0,0,0.2); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        input[type="color"] {
            width: 40px; height: 40px; border: none; background: none; cursor: pointer; padding: 0;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: 2px solid var(--border); border-radius: 6px; }

        /* æ ¸å¿ƒç”»å¸ƒåŒº */
        .workspace {
            position: relative;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            border: 2px solid var(--border);
            border-radius: 4px;
            overflow: hidden;
            background-image: 
                linear-gradient(45deg, #222 25%, transparent 25%), 
                linear-gradient(-45deg, #222 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #222 75%), 
                linear-gradient(-45deg, transparent 75%, #222 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        canvas { display: block; cursor: crosshair; image-rendering: pixelated; }

        /* æ’­æ”¾æ§åˆ¶æ¡ */
        .timeline {
            margin-top: 20px; width: 512px;
            background: var(--panel); padding: 10px; border-radius: 8px;
            display: flex; flex-direction: column; gap: 8px;
            border: 1px solid var(--border);
        }
        .timeline-controls { display: flex; justify-content: space-between; align-items: center; }
        .progress-container { position: relative; height: 6px; background: #111; border-radius: 3px; width: 100%; overflow: hidden; }
        .progress-bar { height: 100%; background: var(--accent); width: 0%; transition: width 0.1s linear; }
        
        /* å¯¼å‡ºæ¨¡æ€æ¡† */
        #loading {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 999;
            display: none; flex-direction: column; align-items: center; justify-content: center;
        }
        .spinner {
            width: 50px; height: 50px; border: 5px solid #333; border-top-color: var(--accent);
            border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* è°ƒè‰²æ¿é¢„è®¾ */
        .palette { display: flex; gap: 4px; flex-wrap: wrap; max-width: 160px; }
        .swatch { width: 20px; height: 20px; border-radius: 3px; cursor: pointer; border: 1px solid rgba(255,255,255,0.2); }
        .swatch:hover { transform: scale(1.2); z-index: 10; }

    </style>
</head>
<body>

    <div class="toolbar">
        <!-- å·¥å…· -->
        <div class="tool-group">
            <input type="color" id="colorPicker" value="#ff0055" title="Color">
            <div class="palette" id="presetPalette"></div>
        </div>
        <div class="tool-group">
            <button id="btnPen" class="active">âœï¸ Pen</button>
            <button id="btnEraser">ğŸ§¼ Eraser</button>
        </div>
        <div class="tool-group">
            <button id="btnGrid">ğŸ•¸ï¸ Grid</button>
            <button id="btnClear">ğŸ—‘ï¸ Clear</button>
            <button id="btnUndo">â†©ï¸ Undo</button>
        </div>
    </div>

    <div class="workspace">
        <canvas id="pixelCanvas" width="512" height="512"></canvas>
    </div>

    <div class="timeline">
        <div class="timeline-controls">
            <span style="font-size: 12px;">HISTORY PLAYBACK</span>
            <span id="stepCounter" style="font-size: 12px; font-family: monospace; color: #666;">Step: 0/0</span>
        </div>
        <div class="progress-container">
            <div class="progress-bar" id="progressBar"></div>
        </div>
        <div style="display: flex; justify-content: space-between; margin-top: 5px;">
            <button id="btnPlay" style="width: 100px;">â–¶ Play</button>
            <button id="btnExportGIF" style="background: #73daca; color: #1a1b26; border-color: #73daca; font-weight: bold;">ğŸ’¾ Export GIF</button>
        </div>
    </div>

    <div id="loading">
        <div class="spinner"></div>
        <h3 style="color: white;">Rendering GIF...</h3>
        <p id="renderStatus" style="color: #888;">Processing frames</p>
    </div>

    <script>
        // --- é…ç½®ä¸çŠ¶æ€ ---
        const CONFIG = {
            gridSize: 32,     // 32x32 åƒç´ ç½‘æ ¼
            canvasSize: 512,  // ç”»å¸ƒç‰©ç†å°ºå¯¸
            bgColor: null,    // é€æ˜èƒŒæ™¯
            gridColor: 'rgba(255, 255, 255, 0.1)'
        };

        const STATE = {
            isDrawing: false,
            tool: 'pen', // 'pen' or 'eraser'
            color: '#ff0055',
            pixels: Array(CONFIG.gridSize * CONFIG.gridSize).fill(null), // å­˜å‚¨é¢œè‰²æ•°æ®
            history: [], // å†å²è®°å½•æ ˆ (æ¯ä¸€æ­¥çš„ pixels å¿«ç…§)
            showGrid: true,
            isPlaying: false
        };

        // --- DOM å…ƒç´  ---
        const canvas = document.getElementById('pixelCanvas');
        const ctx = canvas.getContext('2d');
        const colorPicker = document.getElementById('colorPicker');
        const progressBar = document.getElementById('progressBar');
        const stepCounter = document.getElementById('stepCounter');
        const loadingScreen = document.getElementById('loading');
        const renderStatus = document.getElementById('renderStatus');
        
        const pixelSize = CONFIG.canvasSize / CONFIG.gridSize;

        // --- åˆå§‹åŒ– ---
        function init() {
            // é¢„è®¾è°ƒè‰²æ¿
            const colors = ['#f7768e', '#ff9e64', '#e0af68', '#9ece6a', '#7aa2f7', '#bb9af7', '#ffffff', '#000000'];
            const palContainer = document.getElementById('presetPalette');
            colors.forEach(c => {
                const s = document.createElement('div');
                s.className = 'swatch';
                s.style.background = c;
                s.onclick = () => setColor(c);
                palContainer.appendChild(s);
            });

            // åˆå§‹åŒ–å†å²
            saveHistory(true);
            drawCanvas();

            // ç»‘å®šå·¥å…·äº‹ä»¶
            document.getElementById('btnPen').onclick = () => setTool('pen');
            document.getElementById('btnEraser').onclick = () => setTool('eraser');
            document.getElementById('btnGrid').onclick = toggleGrid;
            document.getElementById('btnClear').onclick = clearCanvas;
            document.getElementById('btnUndo').onclick = undo;
            document.getElementById('btnPlay').onclick = togglePlayback;
            document.getElementById('btnExportGIF').onclick = exportGIF;
            
            colorPicker.oninput = (e) => setColor(e.target.value);
        }

        // --- ç»˜å›¾é€»è¾‘ ---
        
        function getGridPos(e) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / pixelSize);
            const y = Math.floor((e.clientY - rect.top) / pixelSize);
            return { x, y };
        }

        function paintPixel(x, y) {
            if (x < 0 || x >= CONFIG.gridSize || y < 0 || y >= CONFIG.gridSize) return;
            
            const index = y * CONFIG.gridSize + x;
            const newColor = STATE.tool === 'eraser' ? null : STATE.color;
            
            if (STATE.pixels[index] !== newColor) {
                STATE.pixels[index] = newColor;
                drawCanvas(); // å®æ—¶é‡ç»˜
            }
        }

        canvas.addEventListener('mousedown', (e) => {
            if(STATE.isPlaying) return;
            STATE.isDrawing = true;
            const {x, y} = getGridPos(e);
            paintPixel(x, y);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!STATE.isDrawing) return;
            const {x, y} = getGridPos(e);
            paintPixel(x, y);
        });

        window.addEventListener('mouseup', () => {
            if (STATE.isDrawing) {
                STATE.isDrawing = false;
                saveHistory();
            }
        });

        // --- æ¸²æŸ“å¼•æ“ ---

        function drawCanvas(pixelData = STATE.pixels) {
            // æ¸…ç©º
            ctx.clearRect(0, 0, CONFIG.canvasSize, CONFIG.canvasSize);

            // ç»˜åˆ¶åƒç´ 
            for (let i = 0; i < pixelData.length; i++) {
                if (pixelData[i]) {
                    const x = (i % CONFIG.gridSize) * pixelSize;
                    const y = Math.floor(i / CONFIG.gridSize) * pixelSize;
                    ctx.fillStyle = pixelData[i];
                    ctx.fillRect(x, y, pixelSize, pixelSize);
                }
            }

            // ç»˜åˆ¶ç½‘æ ¼
            if (STATE.showGrid) {
                ctx.strokeStyle = CONFIG.gridColor;
                ctx.lineWidth = 1;
                ctx.beginPath();
                for (let i = 0; i <= CONFIG.gridSize; i++) {
                    const pos = i * pixelSize;
                    ctx.moveTo(pos, 0); ctx.lineTo(pos, CONFIG.canvasSize);
                    ctx.moveTo(0, pos); ctx.lineTo(CONFIG.canvasSize, pos);
                }
                ctx.stroke();
            }
        }

        // --- çŠ¶æ€ç®¡ç† ---

        function setColor(c) {
            STATE.color = c;
            colorPicker.value = c;
            setTool('pen');
        }

        function setTool(t) {
            STATE.tool = t;
            document.getElementById('btnPen').classList.toggle('active', t === 'pen');
            document.getElementById('btnEraser').classList.toggle('active', t === 'eraser');
        }

        function toggleGrid() {
            STATE.showGrid = !STATE.showGrid;
            drawCanvas();
        }

        function saveHistory(initial = false) {
            // æ·±æ‹·è´å½“å‰åƒç´ æ•°æ®
            const snapshot = [...STATE.pixels];
            
            // é¿å…é‡å¤çŠ¶æ€ï¼ˆå¦‚æœä¸åŠ¨é¼ æ ‡ç‚¹å‡»ï¼‰
            if (!initial && STATE.history.length > 0) {
                const last = STATE.history[STATE.history.length - 1];
                if (JSON.stringify(last) === JSON.stringify(snapshot)) return;
            }

            STATE.history.push(snapshot);
            updateUI();
        }

        function undo() {
            if (STATE.isPlaying || STATE.history.length <= 1) return;
            STATE.history.pop(); // ç§»é™¤å½“å‰çŠ¶æ€
            STATE.pixels = [...STATE.history[STATE.history.length - 1]]; // æ¢å¤ä¸Šä¸€ä¸ª
            drawCanvas();
            updateUI();
        }

        function clearCanvas() {
            STATE.pixels = Array(CONFIG.gridSize * CONFIG.gridSize).fill(null);
            drawCanvas();
            saveHistory();
        }

        function updateUI() {
            stepCounter.innerText = `Step: ${STATE.history.length}`;
            document.getElementById('btnUndo').disabled = STATE.history.length <= 1;
        }

        // --- å›æ”¾åŠŸèƒ½ ---

        async function togglePlayback() {
            if (STATE.isPlaying) return; // é˜²æ­¢é‡å¤ç‚¹å‡»
            
            STATE.isPlaying = true;
            document.getElementById('btnPlay').innerText = '...Playing';
            
            // ä¸´æ—¶ä¿å­˜å½“å‰çŠ¶æ€ï¼ˆè™½ç„¶é€šå¸¸å°±æ˜¯historyæœ€åä¸€ä¸ªï¼Œä½†ä¸ºäº†ä¿é™©ï¼‰
            const currentPixels = [...STATE.pixels];

            for (let i = 0; i < STATE.history.length; i++) {
                STATE.pixels = STATE.history[i];
                drawCanvas();
                
                // æ›´æ–°è¿›åº¦æ¡
                const pct = ((i + 1) / STATE.history.length) * 100;
                progressBar.style.width = `${pct}%`;
                stepCounter.innerText = `Step: ${i + 1}/${STATE.history.length}`;

                await new Promise(r => setTimeout(r, 100)); // 100ms æ¯å¸§
            }

            // æ¢å¤
            setTimeout(() => {
                STATE.isPlaying = false;
                document.getElementById('btnPlay').innerText = 'â–¶ Play';
                progressBar.style.width = '0%';
                STATE.pixels = currentPixels;
                drawCanvas();
                updateUI();
            }, 500);
        }

        // --- GIF å¯¼å‡ºæ ¸å¿ƒ (Magic Part) ---

        async function exportGIF() {
            if (STATE.history.length === 0) return;
            
            loadingScreen.style.display = 'flex';
            
            // 1. è§£å†³ Worker é—®é¢˜ï¼šåˆ›å»ºä¸€ä¸ª Blob URL æŒ‡å‘ CDN çš„ Worker ä»£ç 
            // å› ä¸ºæœ¬åœ° file:// æ— æ³•åŠ è½½è·¨åŸŸ workerï¼Œæˆ‘ä»¬éœ€è¦ Fetch ä»£ç å¹¶è½¬ä¸º Blob
            let workerBlobUrl = '';
            try {
                const response = await fetch('https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js');
                const workerScript = await response.text();
                const blob = new Blob([workerScript], { type: 'application/javascript' });
                workerBlobUrl = URL.createObjectURL(blob);
            } catch (e) {
                alert('Error loading GIF worker. Ensure internet connection.');
                loadingScreen.style.display = 'none';
                return;
            }

            // 2. åˆå§‹åŒ– GIF ç¼–ç å™¨
            const gif = new GIF({
                workers: 2,
                quality: 10,
                workerScript: workerBlobUrl, // ä½¿ç”¨ Blob URL
                width: CONFIG.canvasSize,
                height: CONFIG.canvasSize,
                transparent: 0x000000 // å¦‚æœéœ€è¦é€æ˜èƒŒæ™¯
            });

            // 3. ç”Ÿæˆå¸§
            // æˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªä¸´æ—¶çš„ Canvas æ¥ç»˜åˆ¶æ¯ä¸€å¸§ï¼ˆä¸å¸¦ç½‘æ ¼ï¼‰
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = CONFIG.canvasSize;
            tempCanvas.height = CONFIG.canvasSize;
            const tCtx = tempCanvas.getContext('2d');

            STATE.history.forEach((framePixels, index) => {
                renderStatus.innerText = `Processing frame ${index + 1}/${STATE.history.length}`;
                
                // ç»˜åˆ¶è¿™ä¸€å¸§åˆ°ä¸´æ—¶ Canvas
                tCtx.clearRect(0, 0, CONFIG.canvasSize, CONFIG.canvasSize);
                
                // èƒŒæ™¯è‰² (ä¸ºäº† GIF ä¸é€æ˜ï¼Œé€šå¸¸å¡«å……ä¸€ä¸ªèƒŒæ™¯è‰²ï¼Œæˆ–è€…ä¿æŒé€æ˜)
                tCtx.fillStyle = '#1a1b26'; // ä½¿ç”¨èƒŒæ™¯è‰²å¡«å……
                tCtx.fillRect(0, 0, CONFIG.canvasSize, CONFIG.canvasSize);

                for (let i = 0; i < framePixels.length; i++) {
                    if (framePixels[i]) {
                        const x = (i % CONFIG.gridSize) * pixelSize;
                        const y = Math.floor(i / CONFIG.gridSize) * pixelSize;
                        tCtx.fillStyle = framePixels[i];
                        tCtx.fillRect(x, y, pixelSize, pixelSize);
                    }
                }

                // æ·»åŠ åˆ° GIFï¼Œæœ€åä¸€å¸§åœç•™æ›´ä¹…
                const delay = (index === STATE.history.length - 1) ? 2000 : 100;
                gif.addFrame(tCtx, {copy: true, delay: delay});
            });

            // 4. æ¸²æŸ“ä¸ä¸‹è½½
            gif.on('finished', (blob) => {
                loadingScreen.style.display = 'none';
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'pixel_art_process.gif';
                a.click();
                URL.revokeObjectURL(workerBlobUrl); // æ¸…ç†
            });

            renderStatus.innerText = 'Encoding GIF...';
            gif.render();
        }

        // å¯åŠ¨
        init();

    </script>
</body>
</html>
```